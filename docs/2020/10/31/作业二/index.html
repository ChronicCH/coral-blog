<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题 作业2: 了解XMLHttpRequest对象XMLHttpRequest 对象用于在后台与服务器交换数据。所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 作用：  在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://chronicch.github.io/2020/10/31/%E4%BD%9C%E4%B8%9A%E4%BA%8C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题 作业2: 了解XMLHttpRequest对象XMLHttpRequest 对象用于在后台与服务器交换数据。所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 作用：  在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="f:/YoudaoNote/weixinobU7VjqUHocAx3oC3CHYYNomdndU/15d6fd38ca5e44dcb26f9227bff0337b/clipboard.png">
<meta property="og:image" content="f:/YoudaoNote/weixinobU7VjqUHocAx3oC3CHYYNomdndU/8702116698b3429ea60c5b154a1baf0f/clipboard.png">
<meta property="og:image" content="f:/YoudaoNote/weixinobU7VjqUHocAx3oC3CHYYNomdndU/edee59fe2c9d461b8deb8241a4121df6/clipboard.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png">
<meta property="og:image" content="f:/YoudaoNote/weixinobU7VjqUHocAx3oC3CHYYNomdndU/1a0ed37738cb43b893fc9187ff3d0429/clipboard.png">
<meta property="article:published_time" content="2020-10-31T08:12:16.568Z">
<meta property="article:modified_time" content="2020-10-31T08:12:16.568Z">
<meta property="article:author" content="Coral">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="f:/YoudaoNote/weixinobU7VjqUHocAx3oC3CHYYNomdndU/15d6fd38ca5e44dcb26f9227bff0337b/clipboard.png">
  
    <link rel="alternate" href="/coral-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/coral-blog/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/coral-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/coral-blog/">Home</a>
        
          <a class="main-nav-link" href="/coral-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/coral-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chronicch.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-作业二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/coral-blog/2020/10/31/%E4%BD%9C%E4%B8%9A%E4%BA%8C/" class="article-date">
  <time datetime="2020-10-31T08:12:16.568Z" itemprop="datePublished">2020-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题"><a href="#作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题" class="headerlink" title="作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题"></a>作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题</h3><hr>
<h3 id="作业2-了解XMLHttpRequest对象"><a href="#作业2-了解XMLHttpRequest对象" class="headerlink" title="作业2: 了解XMLHttpRequest对象"></a>作业2: 了解XMLHttpRequest对象</h3><p><strong>XMLHttpRequest 对象用于在后台与服务器交换数据。</strong>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>
<p>作用：</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<blockquote>
<p>2-1 XMLHttpRequest 对象的语法</p>
</blockquote>
<ul>
<li>创建 XMLHttpRequest 对象的语法：</li>
</ul>
<p><code>var xmlhttp=new XMLHttpRequest();</code></p>
<ul>
<li>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var xmlhttp;</span><br><span class="line"></span><br><span class="line">if (window.XMLHttpRequest)&#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class="line"></span><br><span class="line">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class="line"></span><br><span class="line">    xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2-2 请求和响应</p>
</blockquote>
<p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>
<p><code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);</code></p>
<p><code>xmlhttp.send();</code></p>
<p><img src="F:\YoudaoNote\weixinobU7VjqUHocAx3oC3CHYYNomdndU\15d6fd38ca5e44dcb26f9227bff0337b\clipboard.png" alt="img"></p>
<blockquote>
<p>2-2-1 GET还是POST？</p>
</blockquote>
<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<ul>
<li><ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
</li>
</ul>
<blockquote>
<p>2-2-2 服务器响应</p>
</blockquote>
<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>
<p><img src="F:\YoudaoNote\weixinobU7VjqUHocAx3oC3CHYYNomdndU\8702116698b3429ea60c5b154a1baf0f\clipboard.png" alt="img"></p>
<blockquote>
<p>2-3 onreadystatechange 事件</p>
</blockquote>
<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。</p>
<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>
<p><img src="F:\YoudaoNote\weixinobU7VjqUHocAx3oC3CHYYNomdndU\edee59fe2c9d461b8deb8241a4121df6\clipboard.png" alt="img"></p>
<p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>
<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">   if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class="line">        document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</em></p>
<hr>
<h3 id="作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链"><a href="#作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链" class="headerlink" title="作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链"></a>作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链</h3><blockquote>
<p>3-1  prototype</p>
</blockquote>
<p>所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(age) &#123;</span><br><span class="line">    this.age &#x3D; age       </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name &#x3D; &#39;kavin&#39;</span><br><span class="line">var person1 &#x3D; new Person()</span><br><span class="line">var person2 &#x3D; new Person()</span><br><span class="line">console.log(person1.name) &#x2F;&#x2F;kavin</span><br><span class="line">console.log(person2.name)  &#x2F;&#x2F;kavin</span><br></pre></td></tr></table></figure>

<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>
<blockquote>
<p>3-2  _proto__</p>
</blockquote>
<p>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3-3 constructor</p>
</blockquote>
<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Person&#x3D;&#x3D;&#x3D;Person.prototype.constructor)  &#x2F;&#x2F;true</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;补充说明</span><br><span class="line">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<p><code>person.constructor === Person.prototype.constructor</code></p>
<blockquote>
<p>3-4 实例和原型</p>
</blockquote>
<p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<p>原型的原型：</p>
<p>原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class="line">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3-5 原型链</p>
</blockquote>
<p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图也可以更新为：</p>
<p><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png"></p>
<hr>
<h3 id="作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。"><a href="#作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。" class="headerlink" title="作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。"></a>作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</h3><h4 id="1-arguments对象"><a href="#1-arguments对象" class="headerlink" title="1.arguments对象"></a>1.arguments对象</h4><p><strong>1-1 定义</strong></p>
<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>
<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function (one) &#123;</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">  console.log(arguments[1]);</span><br><span class="line">  console.log(arguments[2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3)</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function(a, b) &#123;</span><br><span class="line">  arguments[0] &#x3D; 3;</span><br><span class="line">  arguments[1] &#x3D; 2;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 1) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>
<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function(a, b) &#123;</span><br><span class="line">  &#39;use strict&#39;; &#x2F;&#x2F; 开启严格模式</span><br><span class="line">  arguments[0] &#x3D; 3;</span><br><span class="line">  arguments[1] &#x3D; 2;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>
<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return arguments.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) &#x2F;&#x2F; 3</span><br><span class="line">f(1) &#x2F;&#x2F; 1</span><br><span class="line">f() &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p><strong>（2）与数组的关系</strong></p>
<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">var args &#x3D; [];</span><br><span class="line">for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">  args.push(arguments[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）callee 属性</strong></p>
<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  console.log(arguments.callee &#x3D;&#x3D;&#x3D; f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>
<h4 id="2-break和continue"><a href="#2-break和continue" class="headerlink" title="2.break和continue"></a>2.break和continue</h4><p>break：跳出循环语句</p>
<p>continue：跳过循环中的一个迭代</p>
<h4 id="3-const、let、var"><a href="#3-const、let、var" class="headerlink" title="3.const、let、var"></a>3.const、let、var</h4><p>js中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。</p>
<p>区别：</p>
<ul>
<li>const定义的变量不可以修改，而且必须初始化。<ul>
<li>const一般用来声明常量</li>
<li>与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const b &#x3D; 2;&#x2F;&#x2F;正确</span><br><span class="line">&#x2F;&#x2F; const b;&#x2F;&#x2F;错误，必须初始化 </span><br><span class="line">console.log(&#39;函数外const定义b：&#39; + b);&#x2F;&#x2F;有输出值</span><br><span class="line">&#x2F;&#x2F; b &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; console.log(&#39;函数外修改const定义b：&#39; + b);&#x2F;&#x2F;无法输出 </span><br></pre></td></tr></table></figure>



<ul>
<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。<ul>
<li>var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效</li>
<li>存在变量声明提前</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; var a;&#x2F;&#x2F;不会报错</span><br><span class="line">console.log(&#39;函数外var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;1</span><br><span class="line">function change()&#123;</span><br><span class="line">a &#x3D; 4;</span><br><span class="line">console.log(&#39;函数内var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br><span class="line">&#125; </span><br><span class="line">change();</span><br><span class="line">console.log(&#39;函数调用后var定义a为函数内部修改值：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br></pre></td></tr></table></figure>



<ul>
<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。<ul>
<li>不存在声明提前</li>
<li>存在暂时性死区</li>
<li>不能重复定义。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let c &#x3D; 3;</span><br><span class="line">console.log(&#39;函数外let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class="line">function change()&#123;</span><br><span class="line">let c &#x3D; 6;</span><br><span class="line">console.log(&#39;函数内let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;6</span><br><span class="line">&#125; </span><br><span class="line">change();</span><br><span class="line">console.log(&#39;函数调用后let定义c不受函数内部定义影响：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;暂时性死区</span><br><span class="line">var a&#x3D;1；</span><br><span class="line">if(1)&#123;</span><br><span class="line"> console.log(a); </span><br><span class="line">  let a&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</em></p>
<h4 id="4-case、default"><a href="#4-case、default" class="headerlink" title="4.case、default"></a>4.case、default</h4><p> case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p>switch case 语句语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(expression)&#123;</span><br><span class="line">    case value :</span><br><span class="line">       &#x2F;&#x2F;语句</span><br><span class="line">       break; &#x2F;&#x2F;可选</span><br><span class="line">    case value :</span><br><span class="line">       &#x2F;&#x2F;语句</span><br><span class="line">       break; &#x2F;&#x2F;可选</span><br><span class="line">    &#x2F;&#x2F;你可以有任意数量的case语句</span><br><span class="line">    default : &#x2F;&#x2F;可选</span><br><span class="line">       &#x2F;&#x2F;语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-try、catch、finally、throw"><a href="#5-try、catch、finally、throw" class="headerlink" title="5.try、catch、finally、throw"></a>5.try、catch、finally、throw</h4><p>try/catch/finally 语句用于处理代码中可能出现的错误信息。</p>
<p><strong>try</strong>语句允许我们定义在执行时进行错误测试的代码块。</p>
<p><strong>catch</strong> 语句允许我们定义当 <strong>try</strong> 代码块发生错误时，所执行的代码块。</p>
<p><strong>finally</strong> 语句在 try 和 catch 之后无论有无异常都会执行。</p>
<p>当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 <a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-throw.html">throw</a> 语句 来创建自定义消息(抛出异常)。如果你将 <strong>throw</strong> 和 <strong>try</strong> 、 <strong>catch</strong>一起使用，就可以控制程序输出的错误信息。</p>
<p><em>注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    tryCode - 尝试执行代码块</span><br><span class="line">&#125;</span><br><span class="line">catch(err) &#123;</span><br><span class="line">    catchCode - 捕获错误的代码块</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;例：</span><br><span class="line">    if(x &#x3D;&#x3D; &quot;&quot;) throw &quot;is Empty&quot;;</span><br><span class="line">        if(isNaN(x)) throw &quot;not a number&quot;;</span><br><span class="line">        if(x &gt; 10) throw &quot;too high&quot;;</span><br><span class="line">        if(x &lt; 5) throw &quot;too low&quot;;</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    finallyCode - 无论 try &#x2F; catch 结果如何都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-class"><a href="#6-class" class="headerlink" title="6.class"></a>6.class</h4><p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。</p>
<p>class 的本质是 function。</p>
<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>
<h4 id="7-debugger"><a href="#7-debugger" class="headerlink" title="7.debugger"></a>7.debugger</h4><p>debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。</p>
<h4 id="8-delete"><a href="#8-delete" class="headerlink" title="8.delete"></a>8.delete</h4><p>delete可以删除对象属性及变量。<code>delete obj.name;</code></p>
<p><em>delete只能删除对象自己的属性，不能删除其原型链上的属性</em></p>
<h4 id="9-instanceof"><a href="#9-instanceof" class="headerlink" title="9.instanceof"></a>9.instanceof</h4><hr>
<h3 id="作业5：把其他同学class2的作业阅读学习一遍"><a href="#作业5：把其他同学class2的作业阅读学习一遍" class="headerlink" title="作业5：把其他同学class2的作业阅读学习一遍"></a>作业5：把其他同学class2的作业阅读学习一遍</h3><h4 id="1-学习AJAX是什么，AJAX实现方法"><a href="#1-学习AJAX是什么，AJAX实现方法" class="headerlink" title="1.学习AJAX是什么，AJAX实现方法"></a>1.学习AJAX是什么，AJAX实现方法</h4><p><strong>1-1. 什么是AJAX？</strong></p>
<ul>
<li>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</li>
<li>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</li>
<li>Ajax 是一种用于创建快速动态网页的技术。</li>
<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
</ul>
<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<ul>
<li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>
</ul>
<p><strong>1-2. AJAX工作原理</strong></p>
<p><img src="F:\YoudaoNote\weixinobU7VjqUHocAx3oC3CHYYNomdndU\1a0ed37738cb43b893fc9187ff3d0429\clipboard.png" alt="img"></p>
<p><strong>1-3. AJAX是基于现有的Internet标准</strong></p>
<ul>
<li><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p>
</li>
<li><ul>
<li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li>
<li>JavaScript/DOM (信息显示/交互)</li>
<li>CSS (给数据定义样式)</li>
<li>XML (作为转换数据的格式)</li>
</ul>
</li>
<li><p>AJAX应用程序与浏览器和平台无关的！</p>
</li>
<li><p>Ajax编程步骤：</p>
<ul>
<li>创建XMLHttpRequest对象。</li>
<li>设置请求方式。</li>
<li>调用回调函数。</li>
<li>发送请求。</li>
</ul>
</li>
</ul>
<p><strong>1-4.原生JavaScript实现AJAX</strong></p>
<p>XMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;原生js实现ajax&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;定义方法</span><br><span class="line">        function fun() &#123;</span><br><span class="line">            &#x2F;&#x2F;发送异步请求</span><br><span class="line">            &#x2F;&#x2F;1.创建核心对象</span><br><span class="line">            var xmlhttp;</span><br><span class="line">            if (window.XMLHttpRequest)&#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">                xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class="line">            &#125;else&#123;&#x2F;&#x2F; code for IE6, IE5</span><br><span class="line">                xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;2.建立连接</span><br><span class="line">            xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username&#x3D;tom&quot;,true);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;3.发送请求</span><br><span class="line">            xmlhttp.send();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;4.接收并处理服务器的响应结果</span><br><span class="line">            &#x2F;&#x2F;获取方式：xmlhttp.responseText</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange</span><br><span class="line">            xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class="line">                &#x2F;&#x2F;判断readyState是否为4，判断status响应状态码是否为200</span><br><span class="line">                if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class="line">                    var responseText &#x3D; xmlhttp.responseText;</span><br><span class="line">                    alert(responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;发送异步请求&quot; onclick&#x3D;&quot;fun()&quot;&gt;</span><br><span class="line">    &lt;input&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>



<h4 id="2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD"><a href="#2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD" class="headerlink" title="2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD"></a>2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD</h4><p><strong>2-1 AMD</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chronicch.github.io/2020/10/31/%E4%BD%9C%E4%B8%9A%E4%BA%8C/" data-id="ckgxnna510001h1tzbnul4419" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/coral-blog/2020/10/24/%E4%BD%9C%E4%B8%9A%E4%B8%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/coral-blog/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/coral-blog/2020/10/31/%E4%BD%9C%E4%B8%9A%E4%BA%8C/">(no title)</a>
          </li>
        
          <li>
            <a href="/coral-blog/2020/10/24/%E4%BD%9C%E4%B8%9A%E4%B8%80/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Coral<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/coral-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/coral-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/coral-blog/fancybox/jquery.fancybox.css">

  
<script src="/coral-blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/coral-blog/js/script.js"></script>




  </div>
</body>
</html>