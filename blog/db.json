{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1603614659159},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1603614665920},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1603614665958},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1603614665967},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1603614665983},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1603614665989},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1603614666711},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1603614666011},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1603614666028},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1603614666069},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1603614666035},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1603614666062},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1603614666110},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1603614666101},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1603614666074},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1603614666107},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1603614666122},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1603614666116},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1603614666608},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1603614666616},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1603614666639},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1603614666688},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1603614666694},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1603614666699},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1603614666634},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1603614666142},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1603614666153},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1603614666162},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1603614666167},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1603614666307},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1603614666344},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1603614666370},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1603614666294},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1603614666363},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1603614666376},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1603614666556},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1603614666586},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1603614666594},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1603614666518},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1603614666716},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1603614666601},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1603614666383},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1603614667105},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1603614667111},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1603614666915},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1603614666590},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1603614667125},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1603614667130},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1603614667120},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1603614666727},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1603614667134},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1603614667183},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1603614667206},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1603614666395},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1603614666409},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1603614667115},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1603614667179},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1603614666485},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1603614667194},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1603614666427},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1603614666908},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1603614666889},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1603614666734},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1603614666764},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1603614666787},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1603614666802},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1603614666809},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1603614666465},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1603614666494},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1603614666844},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1603614666860},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1603614666928},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1603614666825},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1603614666817},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1603614667067},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1603614667153},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1603614667143},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1603614667158},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1603614667163},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1603614666965},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1603614667174},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1603614666874},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1603614667169},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1603614667040},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1603614667010},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1603614667092},{"_id":"public/2020/10/25/hello-world/index.html","hash":"085af5e3d4bd704b73fa38bc296383832818a50c","modified":1604145842978},{"_id":"public/archives/index.html","hash":"181256509ef2ddc256565143206a9569422daabe","modified":1604146899614},{"_id":"public/archives/2020/index.html","hash":"d016ddd5b6a6f5461d114e13323fa5911792f1ca","modified":1604146899614},{"_id":"public/archives/2020/10/index.html","hash":"107b8fd79536c0b2d1cb7046180160c77529bddf","modified":1604146899614},{"_id":"public/index.html","hash":"851e3e8a560acba96ee9b30f4ec25ac1f0158dab","modified":1604146899614},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1604146899614},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1604146899614},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1604146899614},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1604146899614},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1604146899614},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1604146899614},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1604146899614},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1604146899614},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1604146899614},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1604146899614},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1604146899614},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1604146899614},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1604146899614},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1604146899614},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1604146899614},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1604146899614},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1604146899614},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1604146899614},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1604146899614},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1604146899614},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1604146899614},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1604146899614},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1604146899614},{"_id":"source/_posts/note.md","hash":"b0c2bc9386763f1da16372d5578fe63648938d31","modified":1603621606814},{"_id":"public/2020/10/31/note/index.html","hash":"07d2b5c81b8166497f4c8c4e282f9a6874465a3c","modified":1604145842978},{"_id":"source/_posts/作业一.md","hash":"78f852951acd31b4193814b51a7f380037b82326","modified":1603513091353},{"_id":"source/_posts/作业二.md","hash":"edc8b9449eb207e4df96e44683d6ace63f9c89ee","modified":1604131936568},{"_id":"public/2020/10/31/作业二/index.html","hash":"931a0168b449a38564a8c5cd1d6aad9a7096ddd4","modified":1604146899614},{"_id":"public/2020/10/24/作业一/index.html","hash":"93a3ae342a103e2b426c5e8ad0a73b762f168883","modified":1604146899614}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"## 作业1: 学习/复习markdown语法\n\n已看。\n\n---\n\n\n\n## 作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\n\n> 2-1、了解linux的基本命令\n\n- **ls**\n   - ls：列出当前目录下的所有目录\n   - ls -F ：查看目录中的文件 \n   - ls -l ：显示文件和目录的详细资料 \n   - ls -a：显示隐藏文件 \n   - ls *[0-9]* ：显示包含数字的文件名和目录名 \n\n- **cd**\n\n   - cd ~ ： 子系统根目录\n   - cd ：进入个人的主目录\n   - cd ..  ：返回上级目录\n   - cd -  ：返回上次所在目录\n   - cd ../.. ：返回上两级目录\n   - cd /home ：进入‘/home'目录\n\n-  **tree** ：显示文件和目录由根目录开始的树形结构\n\n- **mkdir**：创建一个子目录\n\n- **rm**\n\n   - rm -f file1 删除一个叫做 'file1' 的文件' \n   - rmdir dir1 删除一个叫做 'dir1' 的目录' \n   - rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 \n   - rm -rf dir1 dir2 同时删除两个目录及它们的内容\n\n- **l**: 查看文件大小\n\n- **vi**: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。\n\n  ​\t使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：\n\n  1. 命令模式\n\n     ​\t控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。\n\n     - ①光标移动\n\n       ![image-20201021100752987](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png)\n\n     - ②删除文本\n\n       ![image-20201021100853637](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png)\n\n     - ③删除、复制、粘贴、查找、替换、撤销\n\n       ![image-20201021101000073](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png)\n\n       \n\n  2. 插入模式\n\n     ​\t只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。\n\n     ![image-20201021101108024](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png)\n\n     \n\n  3. 底行模式\n\n     ​\t将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。\n\n  ![image-20201021101215216](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png)\n\n  ​\t注意：在底行模式下的命令，需要按回车键才执行该命令。\n\n  \n\n  4. 切换模式\n\n     ![image-20201021101328117](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png)\n\n     实现以上过程的命令：\n\n     　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；\n\n     　　过程②：按a、i、o或s键，实现命令模式——>插入模式；\n\n     　　过程③：按Esc键，实现插入模式——>命令模式；\n\n     　　过程④：输入：或 /，实现命令模式——>底行模式；\n\n     　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——>命令模式；\n\n     　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。\n\n- **curl**：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。\n\n  语法：`# curl [option] [url]`\n\n  1. 保存访问的网页\n     - 使用linux的重定向功能保存 ` curl http://www.linux.com>>linux.html`\n     - 使用curl的内置option:-o(小写)保存网页 ` curl -o linux.html http://www.linux.com`\n     - 使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）`curl -O http://www.linux.com/hello.sh`\n     \n  2. 测试网页返回值 `curl -o /dev/null -s -w %{http_code} www.linux.com`\n\n     *Ps:在脚本中，这是很常见的测试网站是否正常的用法*\n\n  3. 指定proxy服务器以及其端口\n\n     很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理\n\n     `curl -x 192.168.100.100:1080 http://www.linux.com`\n\n  4. cookie\n\n     - 保存http的response里面的cookie信息。内置option:-c（小写）\n\n       `curl -c cookiec.txt  http://www.linux.com` 保存到cookiec.txt中\n\n     - 保存http的response里面的header信息。内置option: -D\n\n       `curl -D cookied.txt http://www.linux.com`\n\n     - 使用cookie\n\n       很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b\n\n       `curl -b cookiec.txt http://www.linux.com`\n\n  5. 模仿浏览器\n\n     有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站\n\n     `curl -A \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)\" http://www.linux.com`\n\n     这样服务器端就会认为是使用IE8.0去访问的\n\n  6. 伪造referer（盗链）\n\n     很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了\n     curl中内置option：-e可以让我们设定referer\n\n     `curl -e \"www.linux.com\" http://mail.linux.com`\n\n     这样就会让服务器其以为你是从www.linux.com点击某个链接过来的\n\n  7. 下载文件\n\n     - 利用curl下载文件 option：-o(小写大写)\n\n     - 循环下载\n\n       有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5\n\n       ```\n       curl -O http://www.linux.com/dodo[1-5].JPG\n       ```\n\n     - 下载重命名\n\n       `curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG`\n\n       这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖\n\n     - 分块下载\n\n       有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r\n\n       ```\n       # curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG\n       # cat dodo1_part* > dodo1.JPG\n       ```\n\n     - 通过ftp下载文件\n\n       curl提供两种从ftp中下载的语法\n\n       ```\n       curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG\n       curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG\n       ```\n\n     - 显示下载进度条 `curl -# -O http://www.linux.com/dodo1.JPG`\n\n     - 不会显示下载进度信息 `curl -s -O http://www.linux.com/dodo1.JPG`\n\n  8. 断点续传\n\n     在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果\n     如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传\n\n     `curl -C -O http://www.linux.com/dodo1.JPG`\n\n  9. 上传文件\n\n     curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现\n\n     ```\n     curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/\n     ```\n\n     这样就向ftp服务器上传了文件dodo1.JPG\n\n  10. 显示抓取错误 `curl -f http://www.linux.com/error`\n\n- **wget**: wget命令用来从指定的URL下载文件。\n\n   ​\twget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。\n\n   语法：`wget (选项) (url地址)`\n\n   选项：\n\n   | 选项         | 描述                                                      |\n   | ------------ | --------------------------------------------------------- |\n   | -a<日志文件> | 在指定的日志文件中记录资料的执行过程；                    |\n   | -A<后缀名>   | 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；  |\n   | -b           | 进行后台的方式运行wget；                                  |\n   | -B<连接地址> | 设置参考的连接地址的基地地址；                            |\n   | -c           | 继续执行上次终端的任务；                                  |\n   | -C<标志>     | 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； |\n   | -d           | 调试模式运行指令；                                        |\n   | -D<域名列表> | 设置顺着的域名列表，域名之间用“，”分隔；                  |\n   | -e<指令>     | 作为文件“.wgetrc”中的一部分执行指定的指令；               |\n   | -h           | 显示指令帮助信息；                                        |\n   | -i<文件>     | 从指定文件获取要下载的URL地址；                           |\n   | -l<目录列表> | 设置顺着的目录列表，多个目录用“，”分隔；                  |\n   | -L           | 仅顺着关联的连接；                                        |\n   | -r           | 递归下载方式；                                            |\n   | -nc          | 文件存在时，下载文件不覆盖原有文件；                      |\n   | -nv          | 下载时只显示更新和出错信息，不显示指令的详细执行过程；    |\n   | -q           | 不显示指令执行过程；                                      |\n   | -nh          | 不查询主机名称；                                          |\n   | -v           | 显示详细执行过程；                                        |\n   | -V           | 显示版本信息；                                            |\n   | –passive-ftp | 使用被动模式PASV连接FTP服务器；                           |\n   | –follow-ftp  | 从HTML文件中下载FTP连接文件。                             |\n\n   - `wget http://test.com/testfile.zip `->下载指定文件到当前文件夹\n   - `wget -O wordpress.zip http://test.com/download `->指定保存名字\n   - `wget --limit-rate=300k http://www.linuxde.net/testfile.zip `->限制下载速度\n   - `wget -c http://www.linuxde.net/testfile.zip `->断点续传\n   - `wget -b http://www.linuxde.net/testfile.zip` ->后台下载\n\n   > *设置使用指定浏览器下载（伪装下载）*\n\n   - `wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.linuxde.net/testfile.zip`\n\n   - `wget --spider url` ->测试下载\n   - `wget --tries=40 URL` ->设置重试次数为40\n   - `wget -i filelist.txt ->从filelist.txt `  获取下载地址\n\n   > *镜像网站*\n   >\n   > *`--mirror`开户镜像下载。*\n   >\n   > *`-p`下载所有为了`html`页面显示正常的文件。*\n   >\n   > *`--convert-links`下载后，转换成本地的链接。*\n   >\n   > *`-P ./LOCAL`保存所有文件和目录到本地指定目录*\n\n   - `wget --mirror -p --convert-links -P ./LOCAL URL`\n\n   - `wget --reject=gif url` ->下载一个网站，但你不希望下载图片，可以使用这条命令\n   - `wget -o download.log URL `->把下载信息存入日志文件\n   - `wget -Q5m -i filelist.txt` ->限制总下载文件大小\n   - `wget -r -A.pdf url `->下载指定格式文件\n\n   > *FTP下载*\n\n   - `wget ftp-url`\n   - `wget --ftp-user=USERNAME --ftp-password=PASSWORD url`\n\n- **apt-get**: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。\n\n   apt-get命令一般需要root权限执行，所以一般跟着`sudo`命令。\n\n   - **更新、下载**\n\n     > **apt-get update**  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。\n     >\n     > **sudo apt-get install packagename**  :安装一个新软件包\n     >\n     > **upgrate**：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。\n\n   - **删除已安装的包**\n\n     > **apt-get remove packagename**   :  卸载一个已安装的软件包（保留配置文档）\n     >\n     > **apt-get remove --purge packagename**   :卸载一个已安装的软件包（删除配置文档）\n     >\n     > **apt-get autoremove packagename**  :  删除包及其依赖的软件包\n     >\n     > **apt-get autoremove --purge packagname**    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点\n\n   - **清理系统**\n\n     > **apt-get autoclean**   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。\n     >\n     > **apt-get clean**  :  清除检索到的包文件的本地存储库.\n\n   - **apt-cache**\n\n     > search：搜索包\n     >\n     > pkgnames：搜索具有特定名称的包\n     >\n     > showpkg：查看包的详细信息\n\n     \n\n> 2-2、了解学习oh-my-zsh\n\n​\tOh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。\n\n---\n\n\n\n## 作业三：yum是什么\n\n​\t\tYum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的**Shell前端软件包管理器**。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\n​\t\tyum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。\n\n​\t\tyum的常用命令：\n\n| yum check-update              | 列出所有可更新的软件清单                                   |\n| ----------------------------- | ---------------------------------------------------------- |\n| yum update                    | 安装所有更新软件                                           |\n| yum -y install <package_name> | 安装指定的软件                                             |\n| yum update <package_name>     | 更新指定的软件                                             |\n| yum list  <package_name>      | 不加<package_name>列出所有可安裝的软件清单，加了列出指定的 |\n| yum -y remove <package_name>  | 删除软件                                                   |\n| yum search <package_name>     | 查找软件                                                   |\n| yum list installed            | 列出所有已安装的软件包                                     |\n| yum list extras               | 列出所有已安装但不在Yum Repository 內的软件包              |\n| yum clean all                 | 清除缓存目录(/var/cache/yum)下的软件包及旧的headers        |\n| yum info <package_name>       | 不加<package_name>列出所有软件包的信息，加了列出指定的     |\n| yum provides <package_name>   | 列出软件包提供哪些文件                                     |\n| yum clean packages            | 清除缓存目录(/var/cache/yum)下的软件包                     |\n| yum deplist <package_name>    | 显示软件包依赖关系                                         |\n| -y                            | 自动应答yes                                                |\n| -t                            | 忽略错误                                                   |\n| -q                            | 静默执行                                                   |\n| --skip-broken                 | 忽略依赖问题                                               |\n| --nogpgcheck                  | 忽略GPG验证                                                |\n| -R[分钟]                      | 设置等待时间                                               |\n\n","source":"_posts/作业一.md","raw":"## 作业1: 学习/复习markdown语法\n\n已看。\n\n---\n\n\n\n## 作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\n\n> 2-1、了解linux的基本命令\n\n- **ls**\n   - ls：列出当前目录下的所有目录\n   - ls -F ：查看目录中的文件 \n   - ls -l ：显示文件和目录的详细资料 \n   - ls -a：显示隐藏文件 \n   - ls *[0-9]* ：显示包含数字的文件名和目录名 \n\n- **cd**\n\n   - cd ~ ： 子系统根目录\n   - cd ：进入个人的主目录\n   - cd ..  ：返回上级目录\n   - cd -  ：返回上次所在目录\n   - cd ../.. ：返回上两级目录\n   - cd /home ：进入‘/home'目录\n\n-  **tree** ：显示文件和目录由根目录开始的树形结构\n\n- **mkdir**：创建一个子目录\n\n- **rm**\n\n   - rm -f file1 删除一个叫做 'file1' 的文件' \n   - rmdir dir1 删除一个叫做 'dir1' 的目录' \n   - rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 \n   - rm -rf dir1 dir2 同时删除两个目录及它们的内容\n\n- **l**: 查看文件大小\n\n- **vi**: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。\n\n  ​\t使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：\n\n  1. 命令模式\n\n     ​\t控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。\n\n     - ①光标移动\n\n       ![image-20201021100752987](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png)\n\n     - ②删除文本\n\n       ![image-20201021100853637](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png)\n\n     - ③删除、复制、粘贴、查找、替换、撤销\n\n       ![image-20201021101000073](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png)\n\n       \n\n  2. 插入模式\n\n     ​\t只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。\n\n     ![image-20201021101108024](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png)\n\n     \n\n  3. 底行模式\n\n     ​\t将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。\n\n  ![image-20201021101215216](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png)\n\n  ​\t注意：在底行模式下的命令，需要按回车键才执行该命令。\n\n  \n\n  4. 切换模式\n\n     ![image-20201021101328117](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png)\n\n     实现以上过程的命令：\n\n     　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；\n\n     　　过程②：按a、i、o或s键，实现命令模式——>插入模式；\n\n     　　过程③：按Esc键，实现插入模式——>命令模式；\n\n     　　过程④：输入：或 /，实现命令模式——>底行模式；\n\n     　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——>命令模式；\n\n     　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。\n\n- **curl**：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。\n\n  语法：`# curl [option] [url]`\n\n  1. 保存访问的网页\n     - 使用linux的重定向功能保存 ` curl http://www.linux.com>>linux.html`\n     - 使用curl的内置option:-o(小写)保存网页 ` curl -o linux.html http://www.linux.com`\n     - 使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）`curl -O http://www.linux.com/hello.sh`\n     \n  2. 测试网页返回值 `curl -o /dev/null -s -w %{http_code} www.linux.com`\n\n     *Ps:在脚本中，这是很常见的测试网站是否正常的用法*\n\n  3. 指定proxy服务器以及其端口\n\n     很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理\n\n     `curl -x 192.168.100.100:1080 http://www.linux.com`\n\n  4. cookie\n\n     - 保存http的response里面的cookie信息。内置option:-c（小写）\n\n       `curl -c cookiec.txt  http://www.linux.com` 保存到cookiec.txt中\n\n     - 保存http的response里面的header信息。内置option: -D\n\n       `curl -D cookied.txt http://www.linux.com`\n\n     - 使用cookie\n\n       很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b\n\n       `curl -b cookiec.txt http://www.linux.com`\n\n  5. 模仿浏览器\n\n     有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站\n\n     `curl -A \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)\" http://www.linux.com`\n\n     这样服务器端就会认为是使用IE8.0去访问的\n\n  6. 伪造referer（盗链）\n\n     很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了\n     curl中内置option：-e可以让我们设定referer\n\n     `curl -e \"www.linux.com\" http://mail.linux.com`\n\n     这样就会让服务器其以为你是从www.linux.com点击某个链接过来的\n\n  7. 下载文件\n\n     - 利用curl下载文件 option：-o(小写大写)\n\n     - 循环下载\n\n       有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5\n\n       ```\n       curl -O http://www.linux.com/dodo[1-5].JPG\n       ```\n\n     - 下载重命名\n\n       `curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG`\n\n       这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖\n\n     - 分块下载\n\n       有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r\n\n       ```\n       # curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG\n       # cat dodo1_part* > dodo1.JPG\n       ```\n\n     - 通过ftp下载文件\n\n       curl提供两种从ftp中下载的语法\n\n       ```\n       curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG\n       curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG\n       ```\n\n     - 显示下载进度条 `curl -# -O http://www.linux.com/dodo1.JPG`\n\n     - 不会显示下载进度信息 `curl -s -O http://www.linux.com/dodo1.JPG`\n\n  8. 断点续传\n\n     在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果\n     如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传\n\n     `curl -C -O http://www.linux.com/dodo1.JPG`\n\n  9. 上传文件\n\n     curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现\n\n     ```\n     curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/\n     ```\n\n     这样就向ftp服务器上传了文件dodo1.JPG\n\n  10. 显示抓取错误 `curl -f http://www.linux.com/error`\n\n- **wget**: wget命令用来从指定的URL下载文件。\n\n   ​\twget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。\n\n   语法：`wget (选项) (url地址)`\n\n   选项：\n\n   | 选项         | 描述                                                      |\n   | ------------ | --------------------------------------------------------- |\n   | -a<日志文件> | 在指定的日志文件中记录资料的执行过程；                    |\n   | -A<后缀名>   | 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；  |\n   | -b           | 进行后台的方式运行wget；                                  |\n   | -B<连接地址> | 设置参考的连接地址的基地地址；                            |\n   | -c           | 继续执行上次终端的任务；                                  |\n   | -C<标志>     | 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； |\n   | -d           | 调试模式运行指令；                                        |\n   | -D<域名列表> | 设置顺着的域名列表，域名之间用“，”分隔；                  |\n   | -e<指令>     | 作为文件“.wgetrc”中的一部分执行指定的指令；               |\n   | -h           | 显示指令帮助信息；                                        |\n   | -i<文件>     | 从指定文件获取要下载的URL地址；                           |\n   | -l<目录列表> | 设置顺着的目录列表，多个目录用“，”分隔；                  |\n   | -L           | 仅顺着关联的连接；                                        |\n   | -r           | 递归下载方式；                                            |\n   | -nc          | 文件存在时，下载文件不覆盖原有文件；                      |\n   | -nv          | 下载时只显示更新和出错信息，不显示指令的详细执行过程；    |\n   | -q           | 不显示指令执行过程；                                      |\n   | -nh          | 不查询主机名称；                                          |\n   | -v           | 显示详细执行过程；                                        |\n   | -V           | 显示版本信息；                                            |\n   | –passive-ftp | 使用被动模式PASV连接FTP服务器；                           |\n   | –follow-ftp  | 从HTML文件中下载FTP连接文件。                             |\n\n   - `wget http://test.com/testfile.zip `->下载指定文件到当前文件夹\n   - `wget -O wordpress.zip http://test.com/download `->指定保存名字\n   - `wget --limit-rate=300k http://www.linuxde.net/testfile.zip `->限制下载速度\n   - `wget -c http://www.linuxde.net/testfile.zip `->断点续传\n   - `wget -b http://www.linuxde.net/testfile.zip` ->后台下载\n\n   > *设置使用指定浏览器下载（伪装下载）*\n\n   - `wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.linuxde.net/testfile.zip`\n\n   - `wget --spider url` ->测试下载\n   - `wget --tries=40 URL` ->设置重试次数为40\n   - `wget -i filelist.txt ->从filelist.txt `  获取下载地址\n\n   > *镜像网站*\n   >\n   > *`--mirror`开户镜像下载。*\n   >\n   > *`-p`下载所有为了`html`页面显示正常的文件。*\n   >\n   > *`--convert-links`下载后，转换成本地的链接。*\n   >\n   > *`-P ./LOCAL`保存所有文件和目录到本地指定目录*\n\n   - `wget --mirror -p --convert-links -P ./LOCAL URL`\n\n   - `wget --reject=gif url` ->下载一个网站，但你不希望下载图片，可以使用这条命令\n   - `wget -o download.log URL `->把下载信息存入日志文件\n   - `wget -Q5m -i filelist.txt` ->限制总下载文件大小\n   - `wget -r -A.pdf url `->下载指定格式文件\n\n   > *FTP下载*\n\n   - `wget ftp-url`\n   - `wget --ftp-user=USERNAME --ftp-password=PASSWORD url`\n\n- **apt-get**: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。\n\n   apt-get命令一般需要root权限执行，所以一般跟着`sudo`命令。\n\n   - **更新、下载**\n\n     > **apt-get update**  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。\n     >\n     > **sudo apt-get install packagename**  :安装一个新软件包\n     >\n     > **upgrate**：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。\n\n   - **删除已安装的包**\n\n     > **apt-get remove packagename**   :  卸载一个已安装的软件包（保留配置文档）\n     >\n     > **apt-get remove --purge packagename**   :卸载一个已安装的软件包（删除配置文档）\n     >\n     > **apt-get autoremove packagename**  :  删除包及其依赖的软件包\n     >\n     > **apt-get autoremove --purge packagname**    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点\n\n   - **清理系统**\n\n     > **apt-get autoclean**   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。\n     >\n     > **apt-get clean**  :  清除检索到的包文件的本地存储库.\n\n   - **apt-cache**\n\n     > search：搜索包\n     >\n     > pkgnames：搜索具有特定名称的包\n     >\n     > showpkg：查看包的详细信息\n\n     \n\n> 2-2、了解学习oh-my-zsh\n\n​\tOh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。\n\n---\n\n\n\n## 作业三：yum是什么\n\n​\t\tYum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的**Shell前端软件包管理器**。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\n​\t\tyum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。\n\n​\t\tyum的常用命令：\n\n| yum check-update              | 列出所有可更新的软件清单                                   |\n| ----------------------------- | ---------------------------------------------------------- |\n| yum update                    | 安装所有更新软件                                           |\n| yum -y install <package_name> | 安装指定的软件                                             |\n| yum update <package_name>     | 更新指定的软件                                             |\n| yum list  <package_name>      | 不加<package_name>列出所有可安裝的软件清单，加了列出指定的 |\n| yum -y remove <package_name>  | 删除软件                                                   |\n| yum search <package_name>     | 查找软件                                                   |\n| yum list installed            | 列出所有已安装的软件包                                     |\n| yum list extras               | 列出所有已安装但不在Yum Repository 內的软件包              |\n| yum clean all                 | 清除缓存目录(/var/cache/yum)下的软件包及旧的headers        |\n| yum info <package_name>       | 不加<package_name>列出所有软件包的信息，加了列出指定的     |\n| yum provides <package_name>   | 列出软件包提供哪些文件                                     |\n| yum clean packages            | 清除缓存目录(/var/cache/yum)下的软件包                     |\n| yum deplist <package_name>    | 显示软件包依赖关系                                         |\n| -y                            | 自动应答yes                                                |\n| -t                            | 忽略错误                                                   |\n| -q                            | 静默执行                                                   |\n| --skip-broken                 | 忽略依赖问题                                               |\n| --nogpgcheck                  | 忽略GPG验证                                                |\n| -R[分钟]                      | 设置等待时间                                               |\n\n","slug":"作业一","published":1,"date":"2020-10-24T04:18:30.879Z","updated":"2020-10-24T04:18:11.353Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgxnna4t0000h1tzbbzyaksz","content":"<h2 id=\"作业1-学习-复习markdown语法\"><a href=\"#作业1-学习-复习markdown语法\" class=\"headerlink\" title=\"作业1: 学习/复习markdown语法\"></a>作业1: 学习/复习markdown语法</h2><p>已看。</p>\n<hr>\n<h2 id=\"作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\"><a href=\"#作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\" class=\"headerlink\" title=\"作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\"></a>作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh</h2><blockquote>\n<p>2-1、了解linux的基本命令</p>\n</blockquote>\n<ul>\n<li><p><strong>ls</strong></p>\n<ul>\n<li>ls：列出当前目录下的所有目录</li>\n<li>ls -F ：查看目录中的文件 </li>\n<li>ls -l ：显示文件和目录的详细资料 </li>\n<li>ls -a：显示隐藏文件 </li>\n<li>ls <em>[0-9]</em> ：显示包含数字的文件名和目录名 </li>\n</ul>\n</li>\n<li><p><strong>cd</strong></p>\n<ul>\n<li>cd ~ ： 子系统根目录</li>\n<li>cd ：进入个人的主目录</li>\n<li>cd ..  ：返回上级目录</li>\n<li>cd -  ：返回上次所在目录</li>\n<li>cd ../.. ：返回上两级目录</li>\n<li>cd /home ：进入‘/home’目录</li>\n</ul>\n</li>\n<li><p> <strong>tree</strong> ：显示文件和目录由根目录开始的树形结构</p>\n</li>\n<li><p><strong>mkdir</strong>：创建一个子目录</p>\n</li>\n<li><p><strong>rm</strong></p>\n<ul>\n<li>rm -f file1 删除一个叫做 ‘file1’ 的文件’ </li>\n<li>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ </li>\n<li>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 </li>\n<li>rm -rf dir1 dir2 同时删除两个目录及它们的内容</li>\n</ul>\n</li>\n<li><p><strong>l</strong>: 查看文件大小</p>\n</li>\n<li><p><strong>vi</strong>: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。</p>\n<p>​    使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：</p>\n<ol>\n<li><p>命令模式</p>\n<p>​    控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p>\n<ul>\n<li><p>①光标移动</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png\" alt=\"image-20201021100752987\"></p>\n</li>\n<li><p>②删除文本</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png\" alt=\"image-20201021100853637\"></p>\n</li>\n<li><p>③删除、复制、粘贴、查找、替换、撤销</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png\" alt=\"image-20201021101000073\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>插入模式</p>\n<p>​    只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png\" alt=\"image-20201021101108024\"></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>底行模式</p>\n<p>​    将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png\" alt=\"image-20201021101215216\"></p>\n<p>​    注意：在底行模式下的命令，需要按回车键才执行该命令。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>切换模式</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png\" alt=\"image-20201021101328117\"></p>\n<p>实现以上过程的命令：</p>\n<p>　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；</p>\n<p>　　过程②：按a、i、o或s键，实现命令模式——&gt;插入模式；</p>\n<p>　　过程③：按Esc键，实现插入模式——&gt;命令模式；</p>\n<p>　　过程④：输入：或 /，实现命令模式——&gt;底行模式；</p>\n<p>　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——&gt;命令模式；</p>\n<p>　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>curl</strong>：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>\n<p>语法：<code># curl [option] [url]</code></p>\n<ol>\n<li><p>保存访问的网页</p>\n<ul>\n<li>使用linux的重定向功能保存 <code> curl http://www.linux.com&gt;&gt;linux.html</code></li>\n<li>使用curl的内置option:-o(小写)保存网页 <code> curl -o linux.html http://www.linux.com</code></li>\n<li>使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）<code>curl -O http://www.linux.com/hello.sh</code></li>\n</ul>\n</li>\n<li><p>测试网页返回值 <code>curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com</code></p>\n<p><em>Ps:在脚本中，这是很常见的测试网站是否正常的用法</em></p>\n</li>\n<li><p>指定proxy服务器以及其端口</p>\n<p>很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理</p>\n<p><code>curl -x 192.168.100.100:1080 http://www.linux.com</code></p>\n</li>\n<li><p>cookie</p>\n<ul>\n<li><p>保存http的response里面的cookie信息。内置option:-c（小写）</p>\n<p><code>curl -c cookiec.txt  http://www.linux.com</code> 保存到cookiec.txt中</p>\n</li>\n<li><p>保存http的response里面的header信息。内置option: -D</p>\n<p><code>curl -D cookied.txt http://www.linux.com</code></p>\n</li>\n<li><p>使用cookie</p>\n<p>很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b</p>\n<p><code>curl -b cookiec.txt http://www.linux.com</code></p>\n</li>\n</ul>\n</li>\n<li><p>模仿浏览器</p>\n<p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站</p>\n<p><code>curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</code></p>\n<p>这样服务器端就会认为是使用IE8.0去访问的</p>\n</li>\n<li><p>伪造referer（盗链）</p>\n<p>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了<br>curl中内置option：-e可以让我们设定referer</p>\n<p><code>curl -e &quot;www.linux.com&quot; http://mail.linux.com</code></p>\n<p>这样就会让服务器其以为你是从<a href=\"http://www.linux.com点击某个链接过来的/\">www.linux.com点击某个链接过来的</a></p>\n</li>\n<li><p>下载文件</p>\n<ul>\n<li><p>利用curl下载文件 option：-o(小写大写)</p>\n</li>\n<li><p>循环下载</p>\n<p>有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O http:&#x2F;&#x2F;www.linux.com&#x2F;dodo[1-5].JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载重命名</p>\n<p><code>curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</code></p>\n<p>这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</p>\n</li>\n<li><p>分块下载</p>\n<p>有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># curl -r 0-100 -o dodo1_part1.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 100-200 -o dodo1_part2.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 200- -o dodo1_part3.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># cat dodo1_part* &gt; dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过ftp下载文件</p>\n<p>curl提供两种从ftp中下载的语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\">curl -O ftp:&#x2F;&#x2F;用户名:密码@www.linux.com&#x2F;dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示下载进度条 <code>curl -# -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>不会显示下载进度信息 <code>curl -s -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n</ul>\n</li>\n<li><p>断点续传</p>\n<p>在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果<br>如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传</p>\n<p><code>curl -C -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>上传文件</p>\n<p>curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -T dodo1.JPG -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;img&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>这样就向ftp服务器上传了文件dodo1.JPG</p>\n</li>\n<li><p>显示抓取错误 <code>curl -f http://www.linux.com/error</code></p>\n</li>\n</ol>\n</li>\n<li><p><strong>wget</strong>: wget命令用来从指定的URL下载文件。</p>\n<p> ​    wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>\n<p> 语法：<code>wget (选项) (url地址)</code></p>\n<p> 选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a&lt;日志文件&gt;</td>\n<td>在指定的日志文件中记录资料的执行过程；</td>\n</tr>\n<tr>\n<td>-A&lt;后缀名&gt;</td>\n<td>指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>进行后台的方式运行wget；</td>\n</tr>\n<tr>\n<td>-B&lt;连接地址&gt;</td>\n<td>设置参考的连接地址的基地地址；</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>继续执行上次终端的任务；</td>\n</tr>\n<tr>\n<td>-C&lt;标志&gt;</td>\n<td>设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>调试模式运行指令；</td>\n</tr>\n<tr>\n<td>-D&lt;域名列表&gt;</td>\n<td>设置顺着的域名列表，域名之间用“，”分隔；</td>\n</tr>\n<tr>\n<td>-e&lt;指令&gt;</td>\n<td>作为文件“.wgetrc”中的一部分执行指定的指令；</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>显示指令帮助信息；</td>\n</tr>\n<tr>\n<td>-i&lt;文件&gt;</td>\n<td>从指定文件获取要下载的URL地址；</td>\n</tr>\n<tr>\n<td>-l&lt;目录列表&gt;</td>\n<td>设置顺着的目录列表，多个目录用“，”分隔；</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>仅顺着关联的连接；</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归下载方式；</td>\n</tr>\n<tr>\n<td>-nc</td>\n<td>文件存在时，下载文件不覆盖原有文件；</td>\n</tr>\n<tr>\n<td>-nv</td>\n<td>下载时只显示更新和出错信息，不显示指令的详细执行过程；</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>不显示指令执行过程；</td>\n</tr>\n<tr>\n<td>-nh</td>\n<td>不查询主机名称；</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示详细执行过程；</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本信息；</td>\n</tr>\n<tr>\n<td>–passive-ftp</td>\n<td>使用被动模式PASV连接FTP服务器；</td>\n</tr>\n<tr>\n<td>–follow-ftp</td>\n<td>从HTML文件中下载FTP连接文件。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><code>wget http://test.com/testfile.zip </code>-&gt;下载指定文件到当前文件夹</p>\n</li>\n<li><p><code>wget -O wordpress.zip http://test.com/download </code>-&gt;指定保存名字</p>\n</li>\n<li><p><code>wget --limit-rate=300k http://www.linuxde.net/testfile.zip </code>-&gt;限制下载速度</p>\n</li>\n<li><p><code>wget -c http://www.linuxde.net/testfile.zip </code>-&gt;断点续传</p>\n</li>\n<li><p><code>wget -b http://www.linuxde.net/testfile.zip</code> -&gt;后台下载</p>\n<blockquote>\n<p><em>设置使用指定浏览器下载（伪装下载）</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.linuxde.net/testfile.zip</code></p>\n</li>\n<li><p><code>wget --spider url</code> -&gt;测试下载</p>\n</li>\n<li><p><code>wget --tries=40 URL</code> -&gt;设置重试次数为40</p>\n</li>\n<li><p><code>wget -i filelist.txt -&gt;从filelist.txt </code>  获取下载地址</p>\n<blockquote>\n<p><em>镜像网站</em></p>\n<p><em><code>--mirror</code>开户镜像下载。</em></p>\n<p><em><code>-p</code>下载所有为了<code>html</code>页面显示正常的文件。</em></p>\n<p><em><code>--convert-links</code>下载后，转换成本地的链接。</em></p>\n<p><em><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --mirror -p --convert-links -P ./LOCAL URL</code></p>\n</li>\n<li><p><code>wget --reject=gif url</code> -&gt;下载一个网站，但你不希望下载图片，可以使用这条命令</p>\n</li>\n<li><p><code>wget -o download.log URL </code>-&gt;把下载信息存入日志文件</p>\n</li>\n<li><p><code>wget -Q5m -i filelist.txt</code> -&gt;限制总下载文件大小</p>\n</li>\n<li><p><code>wget -r -A.pdf url </code>-&gt;下载指定格式文件</p>\n<blockquote>\n<p><em>FTP下载</em></p>\n</blockquote>\n</li>\n<li><p><code>wget ftp-url</code></p>\n</li>\n<li><p><code>wget --ftp-user=USERNAME --ftp-password=PASSWORD url</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>apt-get</strong>: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。</p>\n<p> apt-get命令一般需要root权限执行，所以一般跟着<code>sudo</code>命令。</p>\n<ul>\n<li><p><strong>更新、下载</strong></p>\n<blockquote>\n<p><strong>apt-get update</strong>  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。</p>\n<p><strong>sudo apt-get install packagename</strong>  :安装一个新软件包</p>\n<p><strong>upgrate</strong>：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。</p>\n</blockquote>\n</li>\n<li><p><strong>删除已安装的包</strong></p>\n<blockquote>\n<p><strong>apt-get remove packagename</strong>   :  卸载一个已安装的软件包（保留配置文档）</p>\n<p><strong>apt-get remove –purge packagename</strong>   :卸载一个已安装的软件包（删除配置文档）</p>\n<p><strong>apt-get autoremove packagename</strong>  :  删除包及其依赖的软件包</p>\n<p><strong>apt-get autoremove –purge packagname</strong>    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点</p>\n</blockquote>\n</li>\n<li><p><strong>清理系统</strong></p>\n<blockquote>\n<p><strong>apt-get autoclean</strong>   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。</p>\n<p><strong>apt-get clean</strong>  :  清除检索到的包文件的本地存储库.</p>\n</blockquote>\n</li>\n<li><p><strong>apt-cache</strong></p>\n<blockquote>\n<p>search：搜索包</p>\n<p>pkgnames：搜索具有特定名称的包</p>\n<p>showpkg：查看包的详细信息</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2、了解学习oh-my-zsh</p>\n</blockquote>\n<p>​    Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p>\n<hr>\n<h2 id=\"作业三：yum是什么\"><a href=\"#作业三：yum是什么\" class=\"headerlink\" title=\"作业三：yum是什么\"></a>作业三：yum是什么</h2><p>​        Yum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的<strong>Shell前端软件包管理器</strong>。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>\n<p>​        yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。</p>\n<p>​        yum的常用命令：</p>\n<table>\n<thead>\n<tr>\n<th>yum check-update</th>\n<th>列出所有可更新的软件清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>yum update</td>\n<td>安装所有更新软件</td>\n</tr>\n<tr>\n<td>yum -y install <package_name></td>\n<td>安装指定的软件</td>\n</tr>\n<tr>\n<td>yum update <package_name></td>\n<td>更新指定的软件</td>\n</tr>\n<tr>\n<td>yum list  <package_name></td>\n<td>不加<package_name>列出所有可安裝的软件清单，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum -y remove <package_name></td>\n<td>删除软件</td>\n</tr>\n<tr>\n<td>yum search <package_name></td>\n<td>查找软件</td>\n</tr>\n<tr>\n<td>yum list installed</td>\n<td>列出所有已安装的软件包</td>\n</tr>\n<tr>\n<td>yum list extras</td>\n<td>列出所有已安装但不在Yum Repository 內的软件包</td>\n</tr>\n<tr>\n<td>yum clean all</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包及旧的headers</td>\n</tr>\n<tr>\n<td>yum info <package_name></td>\n<td>不加<package_name>列出所有软件包的信息，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum provides <package_name></td>\n<td>列出软件包提供哪些文件</td>\n</tr>\n<tr>\n<td>yum clean packages</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包</td>\n</tr>\n<tr>\n<td>yum deplist <package_name></td>\n<td>显示软件包依赖关系</td>\n</tr>\n<tr>\n<td>-y</td>\n<td>自动应答yes</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>忽略错误</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>静默执行</td>\n</tr>\n<tr>\n<td>–skip-broken</td>\n<td>忽略依赖问题</td>\n</tr>\n<tr>\n<td>–nogpgcheck</td>\n<td>忽略GPG验证</td>\n</tr>\n<tr>\n<td>-R[分钟]</td>\n<td>设置等待时间</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"作业1-学习-复习markdown语法\"><a href=\"#作业1-学习-复习markdown语法\" class=\"headerlink\" title=\"作业1: 学习/复习markdown语法\"></a>作业1: 学习/复习markdown语法</h2><p>已看。</p>\n<hr>\n<h2 id=\"作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\"><a href=\"#作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\" class=\"headerlink\" title=\"作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\"></a>作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh</h2><blockquote>\n<p>2-1、了解linux的基本命令</p>\n</blockquote>\n<ul>\n<li><p><strong>ls</strong></p>\n<ul>\n<li>ls：列出当前目录下的所有目录</li>\n<li>ls -F ：查看目录中的文件 </li>\n<li>ls -l ：显示文件和目录的详细资料 </li>\n<li>ls -a：显示隐藏文件 </li>\n<li>ls <em>[0-9]</em> ：显示包含数字的文件名和目录名 </li>\n</ul>\n</li>\n<li><p><strong>cd</strong></p>\n<ul>\n<li>cd ~ ： 子系统根目录</li>\n<li>cd ：进入个人的主目录</li>\n<li>cd ..  ：返回上级目录</li>\n<li>cd -  ：返回上次所在目录</li>\n<li>cd ../.. ：返回上两级目录</li>\n<li>cd /home ：进入‘/home’目录</li>\n</ul>\n</li>\n<li><p> <strong>tree</strong> ：显示文件和目录由根目录开始的树形结构</p>\n</li>\n<li><p><strong>mkdir</strong>：创建一个子目录</p>\n</li>\n<li><p><strong>rm</strong></p>\n<ul>\n<li>rm -f file1 删除一个叫做 ‘file1’ 的文件’ </li>\n<li>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ </li>\n<li>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 </li>\n<li>rm -rf dir1 dir2 同时删除两个目录及它们的内容</li>\n</ul>\n</li>\n<li><p><strong>l</strong>: 查看文件大小</p>\n</li>\n<li><p><strong>vi</strong>: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。</p>\n<p>​    使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：</p>\n<ol>\n<li><p>命令模式</p>\n<p>​    控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p>\n<ul>\n<li><p>①光标移动</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png\" alt=\"image-20201021100752987\"></p>\n</li>\n<li><p>②删除文本</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png\" alt=\"image-20201021100853637\"></p>\n</li>\n<li><p>③删除、复制、粘贴、查找、替换、撤销</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png\" alt=\"image-20201021101000073\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>插入模式</p>\n<p>​    只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png\" alt=\"image-20201021101108024\"></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>底行模式</p>\n<p>​    将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png\" alt=\"image-20201021101215216\"></p>\n<p>​    注意：在底行模式下的命令，需要按回车键才执行该命令。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>切换模式</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png\" alt=\"image-20201021101328117\"></p>\n<p>实现以上过程的命令：</p>\n<p>　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；</p>\n<p>　　过程②：按a、i、o或s键，实现命令模式——&gt;插入模式；</p>\n<p>　　过程③：按Esc键，实现插入模式——&gt;命令模式；</p>\n<p>　　过程④：输入：或 /，实现命令模式——&gt;底行模式；</p>\n<p>　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——&gt;命令模式；</p>\n<p>　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>curl</strong>：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>\n<p>语法：<code># curl [option] [url]</code></p>\n<ol>\n<li><p>保存访问的网页</p>\n<ul>\n<li>使用linux的重定向功能保存 <code> curl http://www.linux.com&gt;&gt;linux.html</code></li>\n<li>使用curl的内置option:-o(小写)保存网页 <code> curl -o linux.html http://www.linux.com</code></li>\n<li>使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）<code>curl -O http://www.linux.com/hello.sh</code></li>\n</ul>\n</li>\n<li><p>测试网页返回值 <code>curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com</code></p>\n<p><em>Ps:在脚本中，这是很常见的测试网站是否正常的用法</em></p>\n</li>\n<li><p>指定proxy服务器以及其端口</p>\n<p>很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理</p>\n<p><code>curl -x 192.168.100.100:1080 http://www.linux.com</code></p>\n</li>\n<li><p>cookie</p>\n<ul>\n<li><p>保存http的response里面的cookie信息。内置option:-c（小写）</p>\n<p><code>curl -c cookiec.txt  http://www.linux.com</code> 保存到cookiec.txt中</p>\n</li>\n<li><p>保存http的response里面的header信息。内置option: -D</p>\n<p><code>curl -D cookied.txt http://www.linux.com</code></p>\n</li>\n<li><p>使用cookie</p>\n<p>很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b</p>\n<p><code>curl -b cookiec.txt http://www.linux.com</code></p>\n</li>\n</ul>\n</li>\n<li><p>模仿浏览器</p>\n<p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站</p>\n<p><code>curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</code></p>\n<p>这样服务器端就会认为是使用IE8.0去访问的</p>\n</li>\n<li><p>伪造referer（盗链）</p>\n<p>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了<br>curl中内置option：-e可以让我们设定referer</p>\n<p><code>curl -e &quot;www.linux.com&quot; http://mail.linux.com</code></p>\n<p>这样就会让服务器其以为你是从<a href=\"http://www.linux.com点击某个链接过来的/\">www.linux.com点击某个链接过来的</a></p>\n</li>\n<li><p>下载文件</p>\n<ul>\n<li><p>利用curl下载文件 option：-o(小写大写)</p>\n</li>\n<li><p>循环下载</p>\n<p>有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O http:&#x2F;&#x2F;www.linux.com&#x2F;dodo[1-5].JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载重命名</p>\n<p><code>curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</code></p>\n<p>这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</p>\n</li>\n<li><p>分块下载</p>\n<p>有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># curl -r 0-100 -o dodo1_part1.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 100-200 -o dodo1_part2.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 200- -o dodo1_part3.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># cat dodo1_part* &gt; dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过ftp下载文件</p>\n<p>curl提供两种从ftp中下载的语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\">curl -O ftp:&#x2F;&#x2F;用户名:密码@www.linux.com&#x2F;dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示下载进度条 <code>curl -# -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>不会显示下载进度信息 <code>curl -s -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n</ul>\n</li>\n<li><p>断点续传</p>\n<p>在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果<br>如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传</p>\n<p><code>curl -C -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>上传文件</p>\n<p>curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -T dodo1.JPG -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;img&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>这样就向ftp服务器上传了文件dodo1.JPG</p>\n</li>\n<li><p>显示抓取错误 <code>curl -f http://www.linux.com/error</code></p>\n</li>\n</ol>\n</li>\n<li><p><strong>wget</strong>: wget命令用来从指定的URL下载文件。</p>\n<p> ​    wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>\n<p> 语法：<code>wget (选项) (url地址)</code></p>\n<p> 选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a&lt;日志文件&gt;</td>\n<td>在指定的日志文件中记录资料的执行过程；</td>\n</tr>\n<tr>\n<td>-A&lt;后缀名&gt;</td>\n<td>指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>进行后台的方式运行wget；</td>\n</tr>\n<tr>\n<td>-B&lt;连接地址&gt;</td>\n<td>设置参考的连接地址的基地地址；</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>继续执行上次终端的任务；</td>\n</tr>\n<tr>\n<td>-C&lt;标志&gt;</td>\n<td>设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>调试模式运行指令；</td>\n</tr>\n<tr>\n<td>-D&lt;域名列表&gt;</td>\n<td>设置顺着的域名列表，域名之间用“，”分隔；</td>\n</tr>\n<tr>\n<td>-e&lt;指令&gt;</td>\n<td>作为文件“.wgetrc”中的一部分执行指定的指令；</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>显示指令帮助信息；</td>\n</tr>\n<tr>\n<td>-i&lt;文件&gt;</td>\n<td>从指定文件获取要下载的URL地址；</td>\n</tr>\n<tr>\n<td>-l&lt;目录列表&gt;</td>\n<td>设置顺着的目录列表，多个目录用“，”分隔；</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>仅顺着关联的连接；</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归下载方式；</td>\n</tr>\n<tr>\n<td>-nc</td>\n<td>文件存在时，下载文件不覆盖原有文件；</td>\n</tr>\n<tr>\n<td>-nv</td>\n<td>下载时只显示更新和出错信息，不显示指令的详细执行过程；</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>不显示指令执行过程；</td>\n</tr>\n<tr>\n<td>-nh</td>\n<td>不查询主机名称；</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示详细执行过程；</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本信息；</td>\n</tr>\n<tr>\n<td>–passive-ftp</td>\n<td>使用被动模式PASV连接FTP服务器；</td>\n</tr>\n<tr>\n<td>–follow-ftp</td>\n<td>从HTML文件中下载FTP连接文件。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><code>wget http://test.com/testfile.zip </code>-&gt;下载指定文件到当前文件夹</p>\n</li>\n<li><p><code>wget -O wordpress.zip http://test.com/download </code>-&gt;指定保存名字</p>\n</li>\n<li><p><code>wget --limit-rate=300k http://www.linuxde.net/testfile.zip </code>-&gt;限制下载速度</p>\n</li>\n<li><p><code>wget -c http://www.linuxde.net/testfile.zip </code>-&gt;断点续传</p>\n</li>\n<li><p><code>wget -b http://www.linuxde.net/testfile.zip</code> -&gt;后台下载</p>\n<blockquote>\n<p><em>设置使用指定浏览器下载（伪装下载）</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.linuxde.net/testfile.zip</code></p>\n</li>\n<li><p><code>wget --spider url</code> -&gt;测试下载</p>\n</li>\n<li><p><code>wget --tries=40 URL</code> -&gt;设置重试次数为40</p>\n</li>\n<li><p><code>wget -i filelist.txt -&gt;从filelist.txt </code>  获取下载地址</p>\n<blockquote>\n<p><em>镜像网站</em></p>\n<p><em><code>--mirror</code>开户镜像下载。</em></p>\n<p><em><code>-p</code>下载所有为了<code>html</code>页面显示正常的文件。</em></p>\n<p><em><code>--convert-links</code>下载后，转换成本地的链接。</em></p>\n<p><em><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --mirror -p --convert-links -P ./LOCAL URL</code></p>\n</li>\n<li><p><code>wget --reject=gif url</code> -&gt;下载一个网站，但你不希望下载图片，可以使用这条命令</p>\n</li>\n<li><p><code>wget -o download.log URL </code>-&gt;把下载信息存入日志文件</p>\n</li>\n<li><p><code>wget -Q5m -i filelist.txt</code> -&gt;限制总下载文件大小</p>\n</li>\n<li><p><code>wget -r -A.pdf url </code>-&gt;下载指定格式文件</p>\n<blockquote>\n<p><em>FTP下载</em></p>\n</blockquote>\n</li>\n<li><p><code>wget ftp-url</code></p>\n</li>\n<li><p><code>wget --ftp-user=USERNAME --ftp-password=PASSWORD url</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>apt-get</strong>: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。</p>\n<p> apt-get命令一般需要root权限执行，所以一般跟着<code>sudo</code>命令。</p>\n<ul>\n<li><p><strong>更新、下载</strong></p>\n<blockquote>\n<p><strong>apt-get update</strong>  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。</p>\n<p><strong>sudo apt-get install packagename</strong>  :安装一个新软件包</p>\n<p><strong>upgrate</strong>：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。</p>\n</blockquote>\n</li>\n<li><p><strong>删除已安装的包</strong></p>\n<blockquote>\n<p><strong>apt-get remove packagename</strong>   :  卸载一个已安装的软件包（保留配置文档）</p>\n<p><strong>apt-get remove –purge packagename</strong>   :卸载一个已安装的软件包（删除配置文档）</p>\n<p><strong>apt-get autoremove packagename</strong>  :  删除包及其依赖的软件包</p>\n<p><strong>apt-get autoremove –purge packagname</strong>    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点</p>\n</blockquote>\n</li>\n<li><p><strong>清理系统</strong></p>\n<blockquote>\n<p><strong>apt-get autoclean</strong>   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。</p>\n<p><strong>apt-get clean</strong>  :  清除检索到的包文件的本地存储库.</p>\n</blockquote>\n</li>\n<li><p><strong>apt-cache</strong></p>\n<blockquote>\n<p>search：搜索包</p>\n<p>pkgnames：搜索具有特定名称的包</p>\n<p>showpkg：查看包的详细信息</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2、了解学习oh-my-zsh</p>\n</blockquote>\n<p>​    Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p>\n<hr>\n<h2 id=\"作业三：yum是什么\"><a href=\"#作业三：yum是什么\" class=\"headerlink\" title=\"作业三：yum是什么\"></a>作业三：yum是什么</h2><p>​        Yum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的<strong>Shell前端软件包管理器</strong>。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>\n<p>​        yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。</p>\n<p>​        yum的常用命令：</p>\n<table>\n<thead>\n<tr>\n<th>yum check-update</th>\n<th>列出所有可更新的软件清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>yum update</td>\n<td>安装所有更新软件</td>\n</tr>\n<tr>\n<td>yum -y install <package_name></td>\n<td>安装指定的软件</td>\n</tr>\n<tr>\n<td>yum update <package_name></td>\n<td>更新指定的软件</td>\n</tr>\n<tr>\n<td>yum list  <package_name></td>\n<td>不加<package_name>列出所有可安裝的软件清单，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum -y remove <package_name></td>\n<td>删除软件</td>\n</tr>\n<tr>\n<td>yum search <package_name></td>\n<td>查找软件</td>\n</tr>\n<tr>\n<td>yum list installed</td>\n<td>列出所有已安装的软件包</td>\n</tr>\n<tr>\n<td>yum list extras</td>\n<td>列出所有已安装但不在Yum Repository 內的软件包</td>\n</tr>\n<tr>\n<td>yum clean all</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包及旧的headers</td>\n</tr>\n<tr>\n<td>yum info <package_name></td>\n<td>不加<package_name>列出所有软件包的信息，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum provides <package_name></td>\n<td>列出软件包提供哪些文件</td>\n</tr>\n<tr>\n<td>yum clean packages</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包</td>\n</tr>\n<tr>\n<td>yum deplist <package_name></td>\n<td>显示软件包依赖关系</td>\n</tr>\n<tr>\n<td>-y</td>\n<td>自动应答yes</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>忽略错误</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>静默执行</td>\n</tr>\n<tr>\n<td>–skip-broken</td>\n<td>忽略依赖问题</td>\n</tr>\n<tr>\n<td>–nogpgcheck</td>\n<td>忽略GPG验证</td>\n</tr>\n<tr>\n<td>-R[分钟]</td>\n<td>设置等待时间</td>\n</tr>\n</tbody></table>\n"},{"_content":"### 作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\n\n\n\n---\n\n### 作业2: 了解XMLHttpRequest对象\n\n**XMLHttpRequest 对象用于在后台与服务器交换数据。**所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。\n\n作用：\n\n- 在不重新加载页面的情况下更新网页\n- 在页面已加载后从服务器请求数据\n- 在页面已加载后从服务器接收数据\n- 在后台向服务器发送数据\n\n> 2-1 XMLHttpRequest 对象的语法\n\n- 创建 XMLHttpRequest 对象的语法：\n\n`var xmlhttp=new XMLHttpRequest();`\n\n- 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：\n\n```\nvar xmlhttp;\n\nif (window.XMLHttpRequest){\n\n\t//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码\n\n    xmlhttp=new XMLHttpRequest();\n\n}else{\n\n    // IE6, IE5 浏览器执行代码\n\n    xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n}\n```\n\n> 2-2 请求和响应\n\n如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：\n\n`xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);`\n\n`xmlhttp.send();`\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png)\n\n> 2-2-1 GET还是POST？\n\n与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。\n\n然而，在以下情况中，请使用 POST 请求：\n\n- - 无法使用缓存文件（更新服务器上的文件或数据库）\n  - 向服务器发送大量数据（POST 没有数据量限制）\n  - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n> 2-2-2 服务器响应\n\n如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png)\n\n> 2-3 onreadystatechange 事件\n\n当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。\n\n下面是 XMLHttpRequest 对象的三个重要的属性：\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png)\n\n在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。\n\n当 readyState 等于 4 且状态为 200 时，表示响应已就绪：\n\n```\nxmlhttp.onreadystatechange=function(){\n   if (xmlhttp.readyState==4 && xmlhttp.status==200){\n        document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n}\n```\n\n*注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。*\n\n\n\n---\n\n### 作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\n\n> 3-1  prototype\n\n所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）\n\n例：\n\n```\nfunction Person(age) {\n    this.age = age       \n}\nPerson.prototype.name = 'kavin'\nvar person1 = new Person()\nvar person2 = new Person()\nconsole.log(person1.name) //kavin\nconsole.log(person2.name)  //kavin\n```\n\n原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。\n\n> 3-2  _proto__\n\n所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）\n\n```\nfunction Person() {\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n> 3-3 constructor\n\n每个原型都有一个constructor属性，指向该关联的构造函数。\n\n```\nfunction Person() {\n}\nconsole.log(Person===Person.prototype.constructor)  //true\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法,可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n//补充说明\nconsole.log(person.constructor === Person); // true\n\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n`person.constructor === Person.prototype.constructor`\n\n> 3-4 实例和原型\n\n 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n原型的原型：\n\n原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```\nvar obj = new Object();\nobj.name = 'Kevin'\nconsole.log(obj.name) // Kevin\n```\n\n> 3-5 原型链\n\n 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》\n\n```\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n\n所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n\n![](https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png)\n\n---\n\n### 作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\n\n#### 1.arguments对象\n\n**1-1 定义**\n\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是`arguments`对象的由来。\n\n`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\n```\nvar f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n}\n\nf(1, 2, 3)\n// 1\n// 2\n// 3\n```\n\n正常模式下，`arguments`对象可以在运行时修改。\n\n```\nvar f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 5\n```\n\n上面代码中，函数`f()`调用时传入的参数，在函数内部被修改成`3`和`2`。\n\n严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。\n\n```\nvar f = function(a, b) {\n  'use strict'; // 开启严格模式\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 2\n```\n\n上面代码中，函数体内是严格模式，这时修改`arguments`对象，不会影响到真实参数`a`和`b`。\n\n通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。\n\n```\nfunction f() {\n  return arguments.length;\n}\n\nf(1, 2, 3) // 3\nf(1) // 1\nf() // 0\n```\n\n**（2）与数组的关系**\n\n需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。\n\n如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。下面是两种常用的转换方法：`slice`方法和逐一填入新数组。\n\n```\nvar args = Array.prototype.slice.call(arguments);\n\n// 或者\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n```\n\n**（3）callee 属性**\n\n`arguments`对象带有一个`callee`属性，返回它所对应的原函数。\n\n```\nvar f = function () {\n  console.log(arguments.callee === f);\n}\n\nf() // true\n```\n\n可以通过`arguments.callee`，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n\n#### 2.break和continue\n\nbreak：跳出循环语句\n\ncontinue：跳过循环中的一个迭代\n\n#### 3.const、let、var\n\njs中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。\n\n区别：\n\n- const定义的变量不可以修改，而且必须初始化。\n  - const一般用来声明常量\n  - 与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义\n\n```\nconst b = 2;//正确\n// const b;//错误，必须初始化 \nconsole.log('函数外const定义b：' + b);//有输出值\n// b = 5;\n// console.log('函数外修改const定义b：' + b);//无法输出 \n```\n\n\n\n- var定义的变量可以修改，如果不初始化会输出undefined，不会报错。\n  - var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效\n  - 存在变量声明提前\n\n```\nvar a = 1;\n// var a;//不会报错\nconsole.log('函数外var定义a：' + a);//可以输出a=1\nfunction change(){\na = 4;\nconsole.log('函数内var定义a：' + a);//可以输出a=4\n} \nchange();\nconsole.log('函数调用后var定义a为函数内部修改值：' + a);//可以输出a=4\n```\n\n\n\n- let是块级作用域，函数内部使用let定义后，对函数外部无影响。\n  - 不存在声明提前\n  - 存在暂时性死区\n  - 不能重复定义。\n\n```\nlet c = 3;\nconsole.log('函数外let定义c：' + c);//输出c=3\nfunction change(){\nlet c = 6;\nconsole.log('函数内let定义c：' + c);//输出c=6\n} \nchange();\nconsole.log('函数调用后let定义c不受函数内部定义影响：' + c);//输出c=3\n\n//暂时性死区\nvar a=1；\nif(1){\n console.log(a); \n  let a=2;\n}\n```\n\n*暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。*\n\n#### 4.case、default\n\n case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch case 语句语法格式如下：\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n#### 5.try、catch、finally、throw\n\ntry/catch/finally 语句用于处理代码中可能出现的错误信息。\n\n**try**语句允许我们定义在执行时进行错误测试的代码块。\n\n**catch** 语句允许我们定义当 **try** 代码块发生错误时，所执行的代码块。\n\n**finally** 语句在 try 和 catch 之后无论有无异常都会执行。\n\n当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 [throw](https://www.runoob.com/jsref/jsref-throw.html) 语句 来创建自定义消息(抛出异常)。如果你将 **throw** 和 **try** 、 **catch**一起使用，就可以控制程序输出的错误信息。\n\n*注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。*\n\n```\ntry {\n    tryCode - 尝试执行代码块\n}\ncatch(err) {\n    catchCode - 捕获错误的代码块\n    \n    //例：\n    if(x == \"\") throw \"is Empty\";\n        if(isNaN(x)) throw \"not a number\";\n        if(x > 10) throw \"too high\";\n        if(x < 5) throw \"too low\";\n}\nfinally {\n    finallyCode - 无论 try / catch 结果如何都会执行的代码块\n}\n```\n\n#### 6.class\n\n在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。\n\nclass 的本质是 function。\n\n它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n\n#### 7.debugger\n\ndebugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。\n\n#### 8.delete\n\ndelete可以删除对象属性及变量。`delete obj.name;`\n\n*delete只能删除对象自己的属性，不能删除其原型链上的属性*\n\n#### 9.instanceof\n\n\n\n---\n\n### 作业5：把其他同学class2的作业阅读学习一遍\n\n\n\n#### 1.学习AJAX是什么，AJAX实现方法\n\n**1-1. 什么是AJAX？**\n\n- Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。\n- Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。\n- Ajax 是一种用于创建快速动态网页的技术。\n- Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n- 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n**1-2. AJAX工作原理**\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png)\n\n**1-3. AJAX是基于现有的Internet标准**\n\n- AJAX是基于现有的Internet标准，并且联合使用它们：\n\n- - XMLHttpRequest 对象 (异步的与服务器交换数据)\n  - JavaScript/DOM (信息显示/交互)\n  - CSS (给数据定义样式)\n  - XML (作为转换数据的格式)\n\n- AJAX应用程序与浏览器和平台无关的！\n\n- Ajax编程步骤：\n  - 创建XMLHttpRequest对象。\n  - 设置请求方式。\n  - 调用回调函数。\n  - 发送请求。\n\n**1-4.原生JavaScript实现AJAX**\n\nXMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。\n\n例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>原生js实现ajax</title>\n    <script>\n        //定义方法\n        function fun() {\n            //发送异步请求\n            //1.创建核心对象\n            var xmlhttp;\n            if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n                xmlhttp=new XMLHttpRequest();\n            }else{// code for IE6, IE5\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            //2.建立连接\n            xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);\n\n            //3.发送请求\n            xmlhttp.send();\n\n            //4.接收并处理服务器的响应结果\n            //获取方式：xmlhttp.responseText\n\n            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange\n            xmlhttp.onreadystatechange=function(){\n                //判断readyState是否为4，判断status响应状态码是否为200\n                if (xmlhttp.readyState==4 && xmlhttp.status==200){\n                    var responseText = xmlhttp.responseText;\n                    alert(responseText);\n                }\n            }\n        }\n    </script>\n</head>\n<body>\n    <input type=\"button\" value=\"发送异步请求\" onclick=\"fun()\">\n    <input>\n</body>\n</html>\n```\n\n\n\n#### 2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\n\n**2-1 AMD**","source":"_posts/作业二.md","raw":"### 作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\n\n\n\n---\n\n### 作业2: 了解XMLHttpRequest对象\n\n**XMLHttpRequest 对象用于在后台与服务器交换数据。**所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。\n\n作用：\n\n- 在不重新加载页面的情况下更新网页\n- 在页面已加载后从服务器请求数据\n- 在页面已加载后从服务器接收数据\n- 在后台向服务器发送数据\n\n> 2-1 XMLHttpRequest 对象的语法\n\n- 创建 XMLHttpRequest 对象的语法：\n\n`var xmlhttp=new XMLHttpRequest();`\n\n- 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：\n\n```\nvar xmlhttp;\n\nif (window.XMLHttpRequest){\n\n\t//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码\n\n    xmlhttp=new XMLHttpRequest();\n\n}else{\n\n    // IE6, IE5 浏览器执行代码\n\n    xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n}\n```\n\n> 2-2 请求和响应\n\n如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：\n\n`xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);`\n\n`xmlhttp.send();`\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png)\n\n> 2-2-1 GET还是POST？\n\n与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。\n\n然而，在以下情况中，请使用 POST 请求：\n\n- - 无法使用缓存文件（更新服务器上的文件或数据库）\n  - 向服务器发送大量数据（POST 没有数据量限制）\n  - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n> 2-2-2 服务器响应\n\n如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png)\n\n> 2-3 onreadystatechange 事件\n\n当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。\n\n下面是 XMLHttpRequest 对象的三个重要的属性：\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png)\n\n在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。\n\n当 readyState 等于 4 且状态为 200 时，表示响应已就绪：\n\n```\nxmlhttp.onreadystatechange=function(){\n   if (xmlhttp.readyState==4 && xmlhttp.status==200){\n        document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n}\n```\n\n*注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。*\n\n\n\n---\n\n### 作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\n\n> 3-1  prototype\n\n所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）\n\n例：\n\n```\nfunction Person(age) {\n    this.age = age       \n}\nPerson.prototype.name = 'kavin'\nvar person1 = new Person()\nvar person2 = new Person()\nconsole.log(person1.name) //kavin\nconsole.log(person2.name)  //kavin\n```\n\n原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。\n\n> 3-2  _proto__\n\n所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）\n\n```\nfunction Person() {\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n> 3-3 constructor\n\n每个原型都有一个constructor属性，指向该关联的构造函数。\n\n```\nfunction Person() {\n}\nconsole.log(Person===Person.prototype.constructor)  //true\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法,可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n//补充说明\nconsole.log(person.constructor === Person); // true\n\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n`person.constructor === Person.prototype.constructor`\n\n> 3-4 实例和原型\n\n 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n原型的原型：\n\n原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```\nvar obj = new Object();\nobj.name = 'Kevin'\nconsole.log(obj.name) // Kevin\n```\n\n> 3-5 原型链\n\n 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》\n\n```\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n\n所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n\n![](https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png)\n\n---\n\n### 作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\n\n#### 1.arguments对象\n\n**1-1 定义**\n\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是`arguments`对象的由来。\n\n`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\n```\nvar f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n}\n\nf(1, 2, 3)\n// 1\n// 2\n// 3\n```\n\n正常模式下，`arguments`对象可以在运行时修改。\n\n```\nvar f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 5\n```\n\n上面代码中，函数`f()`调用时传入的参数，在函数内部被修改成`3`和`2`。\n\n严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。\n\n```\nvar f = function(a, b) {\n  'use strict'; // 开启严格模式\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 2\n```\n\n上面代码中，函数体内是严格模式，这时修改`arguments`对象，不会影响到真实参数`a`和`b`。\n\n通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。\n\n```\nfunction f() {\n  return arguments.length;\n}\n\nf(1, 2, 3) // 3\nf(1) // 1\nf() // 0\n```\n\n**（2）与数组的关系**\n\n需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。\n\n如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。下面是两种常用的转换方法：`slice`方法和逐一填入新数组。\n\n```\nvar args = Array.prototype.slice.call(arguments);\n\n// 或者\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n```\n\n**（3）callee 属性**\n\n`arguments`对象带有一个`callee`属性，返回它所对应的原函数。\n\n```\nvar f = function () {\n  console.log(arguments.callee === f);\n}\n\nf() // true\n```\n\n可以通过`arguments.callee`，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n\n#### 2.break和continue\n\nbreak：跳出循环语句\n\ncontinue：跳过循环中的一个迭代\n\n#### 3.const、let、var\n\njs中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。\n\n区别：\n\n- const定义的变量不可以修改，而且必须初始化。\n  - const一般用来声明常量\n  - 与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义\n\n```\nconst b = 2;//正确\n// const b;//错误，必须初始化 \nconsole.log('函数外const定义b：' + b);//有输出值\n// b = 5;\n// console.log('函数外修改const定义b：' + b);//无法输出 \n```\n\n\n\n- var定义的变量可以修改，如果不初始化会输出undefined，不会报错。\n  - var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效\n  - 存在变量声明提前\n\n```\nvar a = 1;\n// var a;//不会报错\nconsole.log('函数外var定义a：' + a);//可以输出a=1\nfunction change(){\na = 4;\nconsole.log('函数内var定义a：' + a);//可以输出a=4\n} \nchange();\nconsole.log('函数调用后var定义a为函数内部修改值：' + a);//可以输出a=4\n```\n\n\n\n- let是块级作用域，函数内部使用let定义后，对函数外部无影响。\n  - 不存在声明提前\n  - 存在暂时性死区\n  - 不能重复定义。\n\n```\nlet c = 3;\nconsole.log('函数外let定义c：' + c);//输出c=3\nfunction change(){\nlet c = 6;\nconsole.log('函数内let定义c：' + c);//输出c=6\n} \nchange();\nconsole.log('函数调用后let定义c不受函数内部定义影响：' + c);//输出c=3\n\n//暂时性死区\nvar a=1；\nif(1){\n console.log(a); \n  let a=2;\n}\n```\n\n*暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。*\n\n#### 4.case、default\n\n case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch case 语句语法格式如下：\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n#### 5.try、catch、finally、throw\n\ntry/catch/finally 语句用于处理代码中可能出现的错误信息。\n\n**try**语句允许我们定义在执行时进行错误测试的代码块。\n\n**catch** 语句允许我们定义当 **try** 代码块发生错误时，所执行的代码块。\n\n**finally** 语句在 try 和 catch 之后无论有无异常都会执行。\n\n当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 [throw](https://www.runoob.com/jsref/jsref-throw.html) 语句 来创建自定义消息(抛出异常)。如果你将 **throw** 和 **try** 、 **catch**一起使用，就可以控制程序输出的错误信息。\n\n*注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。*\n\n```\ntry {\n    tryCode - 尝试执行代码块\n}\ncatch(err) {\n    catchCode - 捕获错误的代码块\n    \n    //例：\n    if(x == \"\") throw \"is Empty\";\n        if(isNaN(x)) throw \"not a number\";\n        if(x > 10) throw \"too high\";\n        if(x < 5) throw \"too low\";\n}\nfinally {\n    finallyCode - 无论 try / catch 结果如何都会执行的代码块\n}\n```\n\n#### 6.class\n\n在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。\n\nclass 的本质是 function。\n\n它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n\n#### 7.debugger\n\ndebugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。\n\n#### 8.delete\n\ndelete可以删除对象属性及变量。`delete obj.name;`\n\n*delete只能删除对象自己的属性，不能删除其原型链上的属性*\n\n#### 9.instanceof\n\n\n\n---\n\n### 作业5：把其他同学class2的作业阅读学习一遍\n\n\n\n#### 1.学习AJAX是什么，AJAX实现方法\n\n**1-1. 什么是AJAX？**\n\n- Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。\n- Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。\n- Ajax 是一种用于创建快速动态网页的技术。\n- Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n- 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n**1-2. AJAX工作原理**\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png)\n\n**1-3. AJAX是基于现有的Internet标准**\n\n- AJAX是基于现有的Internet标准，并且联合使用它们：\n\n- - XMLHttpRequest 对象 (异步的与服务器交换数据)\n  - JavaScript/DOM (信息显示/交互)\n  - CSS (给数据定义样式)\n  - XML (作为转换数据的格式)\n\n- AJAX应用程序与浏览器和平台无关的！\n\n- Ajax编程步骤：\n  - 创建XMLHttpRequest对象。\n  - 设置请求方式。\n  - 调用回调函数。\n  - 发送请求。\n\n**1-4.原生JavaScript实现AJAX**\n\nXMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。\n\n例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>原生js实现ajax</title>\n    <script>\n        //定义方法\n        function fun() {\n            //发送异步请求\n            //1.创建核心对象\n            var xmlhttp;\n            if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n                xmlhttp=new XMLHttpRequest();\n            }else{// code for IE6, IE5\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            //2.建立连接\n            xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);\n\n            //3.发送请求\n            xmlhttp.send();\n\n            //4.接收并处理服务器的响应结果\n            //获取方式：xmlhttp.responseText\n\n            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange\n            xmlhttp.onreadystatechange=function(){\n                //判断readyState是否为4，判断status响应状态码是否为200\n                if (xmlhttp.readyState==4 && xmlhttp.status==200){\n                    var responseText = xmlhttp.responseText;\n                    alert(responseText);\n                }\n            }\n        }\n    </script>\n</head>\n<body>\n    <input type=\"button\" value=\"发送异步请求\" onclick=\"fun()\">\n    <input>\n</body>\n</html>\n```\n\n\n\n#### 2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\n\n**2-1 AMD**","slug":"作业二","published":1,"date":"2020-10-31T08:12:16.568Z","updated":"2020-10-31T08:12:16.568Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckgxnna510001h1tzbnul4419","content":"<h3 id=\"作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"><a href=\"#作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\" class=\"headerlink\" title=\"作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"></a>作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题</h3><hr>\n<h3 id=\"作业2-了解XMLHttpRequest对象\"><a href=\"#作业2-了解XMLHttpRequest对象\" class=\"headerlink\" title=\"作业2: 了解XMLHttpRequest对象\"></a>作业2: 了解XMLHttpRequest对象</h3><p><strong>XMLHttpRequest 对象用于在后台与服务器交换数据。</strong>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>\n<p>作用：</p>\n<ul>\n<li>在不重新加载页面的情况下更新网页</li>\n<li>在页面已加载后从服务器请求数据</li>\n<li>在页面已加载后从服务器接收数据</li>\n<li>在后台向服务器发送数据</li>\n</ul>\n<blockquote>\n<p>2-1 XMLHttpRequest 对象的语法</p>\n</blockquote>\n<ul>\n<li>创建 XMLHttpRequest 对象的语法：</li>\n</ul>\n<p><code>var xmlhttp=new XMLHttpRequest();</code></p>\n<ul>\n<li>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\"></span><br><span class=\"line\">if (window.XMLHttpRequest)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2-2 请求和响应</p>\n</blockquote>\n<p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>\n<p><code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);</code></p>\n<p><code>xmlhttp.send();</code></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-2-1 GET还是POST？</p>\n</blockquote>\n<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>\n<p>然而，在以下情况中，请使用 POST 请求：</p>\n<ul>\n<li><ul>\n<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>\n<li>向服务器发送大量数据（POST 没有数据量限制）</li>\n<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2-2 服务器响应</p>\n</blockquote>\n<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-3 onreadystatechange 事件</p>\n</blockquote>\n<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。</p>\n<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png\" alt=\"img\"></p>\n<p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>\n<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">   if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">        document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</em></p>\n<hr>\n<h3 id=\"作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\"><a href=\"#作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\" class=\"headerlink\" title=\"作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\"></a>作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链</h3><blockquote>\n<p>3-1  prototype</p>\n</blockquote>\n<p>所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(age) &#123;</span><br><span class=\"line\">    this.age &#x3D; age       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name &#x3D; &#39;kavin&#39;</span><br><span class=\"line\">var person1 &#x3D; new Person()</span><br><span class=\"line\">var person2 &#x3D; new Person()</span><br><span class=\"line\">console.log(person1.name) &#x2F;&#x2F;kavin</span><br><span class=\"line\">console.log(person2.name)  &#x2F;&#x2F;kavin</span><br></pre></td></tr></table></figure>\n\n<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>\n<blockquote>\n<p>3-2  _proto__</p>\n</blockquote>\n<p>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-3 constructor</p>\n</blockquote>\n<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Person&#x3D;&#x3D;&#x3D;Person.prototype.constructor)  &#x2F;&#x2F;true</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class=\"line\">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F;补充说明</span><br><span class=\"line\">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>\n<p><code>person.constructor === Person.prototype.constructor</code></p>\n<blockquote>\n<p>3-4 实例和原型</p>\n</blockquote>\n<p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>\n<p>原型的原型：</p>\n<p>原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; new Object();</span><br><span class=\"line\">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class=\"line\">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-5 原型链</p>\n</blockquote>\n<p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>\n<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>\n<p>最后一张关系图也可以更新为：</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png\"></p>\n<hr>\n<h3 id=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"><a href=\"#作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\" class=\"headerlink\" title=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"></a>作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</h3><h4 id=\"1-arguments对象\"><a href=\"#1-arguments对象\" class=\"headerlink\" title=\"1.arguments对象\"></a>1.arguments对象</h4><p><strong>1-1 定义</strong></p>\n<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>\n<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function (one) &#123;</span><br><span class=\"line\">  console.log(arguments[0]);</span><br><span class=\"line\">  console.log(arguments[1]);</span><br><span class=\"line\">  console.log(arguments[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3)</span><br><span class=\"line\">&#x2F;&#x2F; 1</span><br><span class=\"line\">&#x2F;&#x2F; 2</span><br><span class=\"line\">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>\n<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  &#39;use strict&#39;; &#x2F;&#x2F; 开启严格模式</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>\n<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  return arguments.length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3) &#x2F;&#x2F; 3</span><br><span class=\"line\">f(1) &#x2F;&#x2F; 1</span><br><span class=\"line\">f() &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）与数组的关系</strong></p>\n<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>\n<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者</span><br><span class=\"line\">var args &#x3D; [];</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"line\">  args.push(arguments[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）callee 属性</strong></p>\n<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function () &#123;</span><br><span class=\"line\">  console.log(arguments.callee &#x3D;&#x3D;&#x3D; f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>\n<h4 id=\"2-break和continue\"><a href=\"#2-break和continue\" class=\"headerlink\" title=\"2.break和continue\"></a>2.break和continue</h4><p>break：跳出循环语句</p>\n<p>continue：跳过循环中的一个迭代</p>\n<h4 id=\"3-const、let、var\"><a href=\"#3-const、let、var\" class=\"headerlink\" title=\"3.const、let、var\"></a>3.const、let、var</h4><p>js中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。</p>\n<p>区别：</p>\n<ul>\n<li>const定义的变量不可以修改，而且必须初始化。<ul>\n<li>const一般用来声明常量</li>\n<li>与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b &#x3D; 2;&#x2F;&#x2F;正确</span><br><span class=\"line\">&#x2F;&#x2F; const b;&#x2F;&#x2F;错误，必须初始化 </span><br><span class=\"line\">console.log(&#39;函数外const定义b：&#39; + b);&#x2F;&#x2F;有输出值</span><br><span class=\"line\">&#x2F;&#x2F; b &#x3D; 5;</span><br><span class=\"line\">&#x2F;&#x2F; console.log(&#39;函数外修改const定义b：&#39; + b);&#x2F;&#x2F;无法输出 </span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。<ul>\n<li>var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效</li>\n<li>存在变量声明提前</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F; var a;&#x2F;&#x2F;不会报错</span><br><span class=\"line\">console.log(&#39;函数外var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;1</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">a &#x3D; 4;</span><br><span class=\"line\">console.log(&#39;函数内var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后var定义a为函数内部修改值：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。<ul>\n<li>不存在声明提前</li>\n<li>存在暂时性死区</li>\n<li>不能重复定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c &#x3D; 3;</span><br><span class=\"line\">console.log(&#39;函数外let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">let c &#x3D; 6;</span><br><span class=\"line\">console.log(&#39;函数内let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;6</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后let定义c不受函数内部定义影响：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;暂时性死区</span><br><span class=\"line\">var a&#x3D;1；</span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\"> console.log(a); </span><br><span class=\"line\">  let a&#x3D;2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</em></p>\n<h4 id=\"4-case、default\"><a href=\"#4-case、default\" class=\"headerlink\" title=\"4.case、default\"></a>4.case、default</h4><p> case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>\n<p>switch case 语句语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(expression)&#123;</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    &#x2F;&#x2F;你可以有任意数量的case语句</span><br><span class=\"line\">    default : &#x2F;&#x2F;可选</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-try、catch、finally、throw\"><a href=\"#5-try、catch、finally、throw\" class=\"headerlink\" title=\"5.try、catch、finally、throw\"></a>5.try、catch、finally、throw</h4><p>try/catch/finally 语句用于处理代码中可能出现的错误信息。</p>\n<p><strong>try</strong>语句允许我们定义在执行时进行错误测试的代码块。</p>\n<p><strong>catch</strong> 语句允许我们定义当 <strong>try</strong> 代码块发生错误时，所执行的代码块。</p>\n<p><strong>finally</strong> 语句在 try 和 catch 之后无论有无异常都会执行。</p>\n<p>当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 <a href=\"https://www.runoob.com/jsref/jsref-throw.html\">throw</a> 语句 来创建自定义消息(抛出异常)。如果你将 <strong>throw</strong> 和 <strong>try</strong> 、 <strong>catch</strong>一起使用，就可以控制程序输出的错误信息。</p>\n<p><em>注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    tryCode - 尝试执行代码块</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch(err) &#123;</span><br><span class=\"line\">    catchCode - 捕获错误的代码块</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;例：</span><br><span class=\"line\">    if(x &#x3D;&#x3D; &quot;&quot;) throw &quot;is Empty&quot;;</span><br><span class=\"line\">        if(isNaN(x)) throw &quot;not a number&quot;;</span><br><span class=\"line\">        if(x &gt; 10) throw &quot;too high&quot;;</span><br><span class=\"line\">        if(x &lt; 5) throw &quot;too low&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally &#123;</span><br><span class=\"line\">    finallyCode - 无论 try &#x2F; catch 结果如何都会执行的代码块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-class\"><a href=\"#6-class\" class=\"headerlink\" title=\"6.class\"></a>6.class</h4><p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。</p>\n<p>class 的本质是 function。</p>\n<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h4 id=\"7-debugger\"><a href=\"#7-debugger\" class=\"headerlink\" title=\"7.debugger\"></a>7.debugger</h4><p>debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。</p>\n<h4 id=\"8-delete\"><a href=\"#8-delete\" class=\"headerlink\" title=\"8.delete\"></a>8.delete</h4><p>delete可以删除对象属性及变量。<code>delete obj.name;</code></p>\n<p><em>delete只能删除对象自己的属性，不能删除其原型链上的属性</em></p>\n<h4 id=\"9-instanceof\"><a href=\"#9-instanceof\" class=\"headerlink\" title=\"9.instanceof\"></a>9.instanceof</h4><hr>\n<h3 id=\"作业5：把其他同学class2的作业阅读学习一遍\"><a href=\"#作业5：把其他同学class2的作业阅读学习一遍\" class=\"headerlink\" title=\"作业5：把其他同学class2的作业阅读学习一遍\"></a>作业5：把其他同学class2的作业阅读学习一遍</h3><h4 id=\"1-学习AJAX是什么，AJAX实现方法\"><a href=\"#1-学习AJAX是什么，AJAX实现方法\" class=\"headerlink\" title=\"1.学习AJAX是什么，AJAX实现方法\"></a>1.学习AJAX是什么，AJAX实现方法</h4><p><strong>1-1. 什么是AJAX？</strong></p>\n<ul>\n<li>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</li>\n<li>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</li>\n<li>Ajax 是一种用于创建快速动态网页的技术。</li>\n<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>\n</ul>\n<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<ul>\n<li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>\n</ul>\n<p><strong>1-2. AJAX工作原理</strong></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png\" alt=\"img\"></p>\n<p><strong>1-3. AJAX是基于现有的Internet标准</strong></p>\n<ul>\n<li><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p>\n</li>\n<li><ul>\n<li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li>\n<li>JavaScript/DOM (信息显示/交互)</li>\n<li>CSS (给数据定义样式)</li>\n<li>XML (作为转换数据的格式)</li>\n</ul>\n</li>\n<li><p>AJAX应用程序与浏览器和平台无关的！</p>\n</li>\n<li><p>Ajax编程步骤：</p>\n<ul>\n<li>创建XMLHttpRequest对象。</li>\n<li>设置请求方式。</li>\n<li>调用回调函数。</li>\n<li>发送请求。</li>\n</ul>\n</li>\n</ul>\n<p><strong>1-4.原生JavaScript实现AJAX</strong></p>\n<p>XMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;原生js实现ajax&lt;&#x2F;title&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        &#x2F;&#x2F;定义方法</span><br><span class=\"line\">        function fun() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;发送异步请求</span><br><span class=\"line\">            &#x2F;&#x2F;1.创建核心对象</span><br><span class=\"line\">            var xmlhttp;</span><br><span class=\"line\">            if (window.XMLHttpRequest)&#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class=\"line\">                xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">            &#125;else&#123;&#x2F;&#x2F; code for IE6, IE5</span><br><span class=\"line\">                xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;2.建立连接</span><br><span class=\"line\">            xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username&#x3D;tom&quot;,true);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;3.发送请求</span><br><span class=\"line\">            xmlhttp.send();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;4.接收并处理服务器的响应结果</span><br><span class=\"line\">            &#x2F;&#x2F;获取方式：xmlhttp.responseText</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange</span><br><span class=\"line\">            xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;判断readyState是否为4，判断status响应状态码是否为200</span><br><span class=\"line\">                if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">                    var responseText &#x3D; xmlhttp.responseText;</span><br><span class=\"line\">                    alert(responseText);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;发送异步请求&quot; onclick&#x3D;&quot;fun()&quot;&gt;</span><br><span class=\"line\">    &lt;input&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\"><a href=\"#2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\" class=\"headerlink\" title=\"2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\"></a>2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD</h4><p><strong>2-1 AMD</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"><a href=\"#作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\" class=\"headerlink\" title=\"作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"></a>作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题</h3><hr>\n<h3 id=\"作业2-了解XMLHttpRequest对象\"><a href=\"#作业2-了解XMLHttpRequest对象\" class=\"headerlink\" title=\"作业2: 了解XMLHttpRequest对象\"></a>作业2: 了解XMLHttpRequest对象</h3><p><strong>XMLHttpRequest 对象用于在后台与服务器交换数据。</strong>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>\n<p>作用：</p>\n<ul>\n<li>在不重新加载页面的情况下更新网页</li>\n<li>在页面已加载后从服务器请求数据</li>\n<li>在页面已加载后从服务器接收数据</li>\n<li>在后台向服务器发送数据</li>\n</ul>\n<blockquote>\n<p>2-1 XMLHttpRequest 对象的语法</p>\n</blockquote>\n<ul>\n<li>创建 XMLHttpRequest 对象的语法：</li>\n</ul>\n<p><code>var xmlhttp=new XMLHttpRequest();</code></p>\n<ul>\n<li>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\"></span><br><span class=\"line\">if (window.XMLHttpRequest)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2-2 请求和响应</p>\n</blockquote>\n<p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>\n<p><code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);</code></p>\n<p><code>xmlhttp.send();</code></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-2-1 GET还是POST？</p>\n</blockquote>\n<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>\n<p>然而，在以下情况中，请使用 POST 请求：</p>\n<ul>\n<li><ul>\n<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>\n<li>向服务器发送大量数据（POST 没有数据量限制）</li>\n<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2-2 服务器响应</p>\n</blockquote>\n<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-3 onreadystatechange 事件</p>\n</blockquote>\n<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。</p>\n<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png\" alt=\"img\"></p>\n<p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>\n<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">   if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">        document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</em></p>\n<hr>\n<h3 id=\"作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\"><a href=\"#作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\" class=\"headerlink\" title=\"作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\"></a>作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链</h3><blockquote>\n<p>3-1  prototype</p>\n</blockquote>\n<p>所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(age) &#123;</span><br><span class=\"line\">    this.age &#x3D; age       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name &#x3D; &#39;kavin&#39;</span><br><span class=\"line\">var person1 &#x3D; new Person()</span><br><span class=\"line\">var person2 &#x3D; new Person()</span><br><span class=\"line\">console.log(person1.name) &#x2F;&#x2F;kavin</span><br><span class=\"line\">console.log(person2.name)  &#x2F;&#x2F;kavin</span><br></pre></td></tr></table></figure>\n\n<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>\n<blockquote>\n<p>3-2  _proto__</p>\n</blockquote>\n<p>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-3 constructor</p>\n</blockquote>\n<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Person&#x3D;&#x3D;&#x3D;Person.prototype.constructor)  &#x2F;&#x2F;true</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class=\"line\">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F;补充说明</span><br><span class=\"line\">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>\n<p><code>person.constructor === Person.prototype.constructor</code></p>\n<blockquote>\n<p>3-4 实例和原型</p>\n</blockquote>\n<p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>\n<p>原型的原型：</p>\n<p>原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; new Object();</span><br><span class=\"line\">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class=\"line\">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-5 原型链</p>\n</blockquote>\n<p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>\n<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>\n<p>最后一张关系图也可以更新为：</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png\"></p>\n<hr>\n<h3 id=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"><a href=\"#作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\" class=\"headerlink\" title=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"></a>作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</h3><h4 id=\"1-arguments对象\"><a href=\"#1-arguments对象\" class=\"headerlink\" title=\"1.arguments对象\"></a>1.arguments对象</h4><p><strong>1-1 定义</strong></p>\n<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>\n<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function (one) &#123;</span><br><span class=\"line\">  console.log(arguments[0]);</span><br><span class=\"line\">  console.log(arguments[1]);</span><br><span class=\"line\">  console.log(arguments[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3)</span><br><span class=\"line\">&#x2F;&#x2F; 1</span><br><span class=\"line\">&#x2F;&#x2F; 2</span><br><span class=\"line\">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>\n<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  &#39;use strict&#39;; &#x2F;&#x2F; 开启严格模式</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>\n<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  return arguments.length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3) &#x2F;&#x2F; 3</span><br><span class=\"line\">f(1) &#x2F;&#x2F; 1</span><br><span class=\"line\">f() &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）与数组的关系</strong></p>\n<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>\n<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者</span><br><span class=\"line\">var args &#x3D; [];</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"line\">  args.push(arguments[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）callee 属性</strong></p>\n<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function () &#123;</span><br><span class=\"line\">  console.log(arguments.callee &#x3D;&#x3D;&#x3D; f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>\n<h4 id=\"2-break和continue\"><a href=\"#2-break和continue\" class=\"headerlink\" title=\"2.break和continue\"></a>2.break和continue</h4><p>break：跳出循环语句</p>\n<p>continue：跳过循环中的一个迭代</p>\n<h4 id=\"3-const、let、var\"><a href=\"#3-const、let、var\" class=\"headerlink\" title=\"3.const、let、var\"></a>3.const、let、var</h4><p>js中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。</p>\n<p>区别：</p>\n<ul>\n<li>const定义的变量不可以修改，而且必须初始化。<ul>\n<li>const一般用来声明常量</li>\n<li>与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b &#x3D; 2;&#x2F;&#x2F;正确</span><br><span class=\"line\">&#x2F;&#x2F; const b;&#x2F;&#x2F;错误，必须初始化 </span><br><span class=\"line\">console.log(&#39;函数外const定义b：&#39; + b);&#x2F;&#x2F;有输出值</span><br><span class=\"line\">&#x2F;&#x2F; b &#x3D; 5;</span><br><span class=\"line\">&#x2F;&#x2F; console.log(&#39;函数外修改const定义b：&#39; + b);&#x2F;&#x2F;无法输出 </span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。<ul>\n<li>var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效</li>\n<li>存在变量声明提前</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F; var a;&#x2F;&#x2F;不会报错</span><br><span class=\"line\">console.log(&#39;函数外var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;1</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">a &#x3D; 4;</span><br><span class=\"line\">console.log(&#39;函数内var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后var定义a为函数内部修改值：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。<ul>\n<li>不存在声明提前</li>\n<li>存在暂时性死区</li>\n<li>不能重复定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c &#x3D; 3;</span><br><span class=\"line\">console.log(&#39;函数外let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">let c &#x3D; 6;</span><br><span class=\"line\">console.log(&#39;函数内let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;6</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后let定义c不受函数内部定义影响：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;暂时性死区</span><br><span class=\"line\">var a&#x3D;1；</span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\"> console.log(a); </span><br><span class=\"line\">  let a&#x3D;2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</em></p>\n<h4 id=\"4-case、default\"><a href=\"#4-case、default\" class=\"headerlink\" title=\"4.case、default\"></a>4.case、default</h4><p> case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>\n<p>switch case 语句语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(expression)&#123;</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    &#x2F;&#x2F;你可以有任意数量的case语句</span><br><span class=\"line\">    default : &#x2F;&#x2F;可选</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-try、catch、finally、throw\"><a href=\"#5-try、catch、finally、throw\" class=\"headerlink\" title=\"5.try、catch、finally、throw\"></a>5.try、catch、finally、throw</h4><p>try/catch/finally 语句用于处理代码中可能出现的错误信息。</p>\n<p><strong>try</strong>语句允许我们定义在执行时进行错误测试的代码块。</p>\n<p><strong>catch</strong> 语句允许我们定义当 <strong>try</strong> 代码块发生错误时，所执行的代码块。</p>\n<p><strong>finally</strong> 语句在 try 和 catch 之后无论有无异常都会执行。</p>\n<p>当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 <a href=\"https://www.runoob.com/jsref/jsref-throw.html\">throw</a> 语句 来创建自定义消息(抛出异常)。如果你将 <strong>throw</strong> 和 <strong>try</strong> 、 <strong>catch</strong>一起使用，就可以控制程序输出的错误信息。</p>\n<p><em>注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    tryCode - 尝试执行代码块</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch(err) &#123;</span><br><span class=\"line\">    catchCode - 捕获错误的代码块</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;例：</span><br><span class=\"line\">    if(x &#x3D;&#x3D; &quot;&quot;) throw &quot;is Empty&quot;;</span><br><span class=\"line\">        if(isNaN(x)) throw &quot;not a number&quot;;</span><br><span class=\"line\">        if(x &gt; 10) throw &quot;too high&quot;;</span><br><span class=\"line\">        if(x &lt; 5) throw &quot;too low&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally &#123;</span><br><span class=\"line\">    finallyCode - 无论 try &#x2F; catch 结果如何都会执行的代码块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-class\"><a href=\"#6-class\" class=\"headerlink\" title=\"6.class\"></a>6.class</h4><p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。</p>\n<p>class 的本质是 function。</p>\n<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h4 id=\"7-debugger\"><a href=\"#7-debugger\" class=\"headerlink\" title=\"7.debugger\"></a>7.debugger</h4><p>debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。</p>\n<h4 id=\"8-delete\"><a href=\"#8-delete\" class=\"headerlink\" title=\"8.delete\"></a>8.delete</h4><p>delete可以删除对象属性及变量。<code>delete obj.name;</code></p>\n<p><em>delete只能删除对象自己的属性，不能删除其原型链上的属性</em></p>\n<h4 id=\"9-instanceof\"><a href=\"#9-instanceof\" class=\"headerlink\" title=\"9.instanceof\"></a>9.instanceof</h4><hr>\n<h3 id=\"作业5：把其他同学class2的作业阅读学习一遍\"><a href=\"#作业5：把其他同学class2的作业阅读学习一遍\" class=\"headerlink\" title=\"作业5：把其他同学class2的作业阅读学习一遍\"></a>作业5：把其他同学class2的作业阅读学习一遍</h3><h4 id=\"1-学习AJAX是什么，AJAX实现方法\"><a href=\"#1-学习AJAX是什么，AJAX实现方法\" class=\"headerlink\" title=\"1.学习AJAX是什么，AJAX实现方法\"></a>1.学习AJAX是什么，AJAX实现方法</h4><p><strong>1-1. 什么是AJAX？</strong></p>\n<ul>\n<li>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</li>\n<li>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</li>\n<li>Ajax 是一种用于创建快速动态网页的技术。</li>\n<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>\n</ul>\n<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<ul>\n<li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>\n</ul>\n<p><strong>1-2. AJAX工作原理</strong></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png\" alt=\"img\"></p>\n<p><strong>1-3. AJAX是基于现有的Internet标准</strong></p>\n<ul>\n<li><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p>\n</li>\n<li><ul>\n<li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li>\n<li>JavaScript/DOM (信息显示/交互)</li>\n<li>CSS (给数据定义样式)</li>\n<li>XML (作为转换数据的格式)</li>\n</ul>\n</li>\n<li><p>AJAX应用程序与浏览器和平台无关的！</p>\n</li>\n<li><p>Ajax编程步骤：</p>\n<ul>\n<li>创建XMLHttpRequest对象。</li>\n<li>设置请求方式。</li>\n<li>调用回调函数。</li>\n<li>发送请求。</li>\n</ul>\n</li>\n</ul>\n<p><strong>1-4.原生JavaScript实现AJAX</strong></p>\n<p>XMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;原生js实现ajax&lt;&#x2F;title&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        &#x2F;&#x2F;定义方法</span><br><span class=\"line\">        function fun() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;发送异步请求</span><br><span class=\"line\">            &#x2F;&#x2F;1.创建核心对象</span><br><span class=\"line\">            var xmlhttp;</span><br><span class=\"line\">            if (window.XMLHttpRequest)&#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class=\"line\">                xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">            &#125;else&#123;&#x2F;&#x2F; code for IE6, IE5</span><br><span class=\"line\">                xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;2.建立连接</span><br><span class=\"line\">            xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username&#x3D;tom&quot;,true);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;3.发送请求</span><br><span class=\"line\">            xmlhttp.send();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;4.接收并处理服务器的响应结果</span><br><span class=\"line\">            &#x2F;&#x2F;获取方式：xmlhttp.responseText</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange</span><br><span class=\"line\">            xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;判断readyState是否为4，判断status响应状态码是否为200</span><br><span class=\"line\">                if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">                    var responseText &#x3D; xmlhttp.responseText;</span><br><span class=\"line\">                    alert(responseText);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;发送异步请求&quot; onclick&#x3D;&quot;fun()&quot;&gt;</span><br><span class=\"line\">    &lt;input&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\"><a href=\"#2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\" class=\"headerlink\" title=\"2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\"></a>2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD</h4><p><strong>2-1 AMD</strong></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}