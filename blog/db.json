{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-simperlog/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-simperlog/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-simperlog/source/css/images/portrait.png","path":"css/images/portrait.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1604190973715},{"_id":"themes/hexo-theme-simperlog/README.md","hash":"d576daba6ef77e5f801f339fff2775e83f0271a7","modified":1604191413081},{"_id":"themes/hexo-theme-simperlog/_config.yml","hash":"54b7b183235e1105cd301be7ae97d7f9310bf402","modified":1604191413089},{"_id":"themes/hexo-theme-simperlog/languages/en.yml","hash":"f0d25d7ab361630f7922eade4619670b819f54ce","modified":1604191413098},{"_id":"themes/hexo-theme-simperlog/layout/index.ejs","hash":"b82f14952c9972373fc3071584a6ab696de314df","modified":1604191413403},{"_id":"themes/hexo-theme-simperlog/layout/layout.ejs","hash":"38216b9e5094ecf3cfe04bcc55ec5417dfeb4589","modified":1604191413420},{"_id":"themes/hexo-theme-simperlog/layout/page.ejs","hash":"d6a62b9548daaf145bfab478d7ee8e1178529a44","modified":1604191413455},{"_id":"themes/hexo-theme-simperlog/scripts/fancybox.js","hash":"e4b696a418c63ffbbc1bbc417e521c88f78d9d7f","modified":1604191413485},{"_id":"themes/hexo-theme-simperlog/layout/post.ejs","hash":"e20733052c0cd55319218e1acaecfd9a4c2accc8","modified":1604191413471},{"_id":"themes/hexo-theme-simperlog/scripts/inline-css.js","hash":"566ac5312986c03a1ed1bbe2fa631020e99fa72f","modified":1604191413500},{"_id":"themes/hexo-theme-simperlog/layout/_partial/after-footer.ejs","hash":"4e138d36ce5381f02f64886adbf343ac5da46551","modified":1604191413112},{"_id":"themes/hexo-theme-simperlog/layout/_partial/article.ejs","hash":"025d3a4255c48942de46fb2e50590de5947684c7","modified":1604191413141},{"_id":"themes/hexo-theme-simperlog/layout/_partial/footer.ejs","hash":"221e8d8f8f860ee6167ba64e5902b0ce38d54b3e","modified":1604191413179},{"_id":"themes/hexo-theme-simperlog/layout/_partial/google-analytics.ejs","hash":"422e3fd03eba540669ffd7c6eb10830562fab1af","modified":1604191413195},{"_id":"themes/hexo-theme-simperlog/layout/_partial/header.ejs","hash":"eca118f5231815c967ecdff1b2a47f302aff1cdd","modified":1604191413237},{"_id":"themes/hexo-theme-simperlog/layout/_partial/head.ejs","hash":"747225f8e132e2d02275791c851efb254ebb9806","modified":1604191413212},{"_id":"themes/hexo-theme-simperlog/layout/_widget/contact.ejs","hash":"c201320f4143302e6f46e7d3d9f1460117e4840e","modified":1604191413374},{"_id":"themes/hexo-theme-simperlog/layout/_partial/sidebar.ejs","hash":"e0ea1c5867ec8274a61a0cafc1aafdc17d0ff2b8","modified":1604191413345},{"_id":"themes/hexo-theme-simperlog/layout/_widget/about.ejs","hash":"5384c7f16ae8708db762f6ee7eadb7c1ef85ee31","modified":1604191413360},{"_id":"themes/hexo-theme-simperlog/source/css/_extend.styl","hash":"71e5a4d04daa7011f8bb1ea1e95d212686bdd87e","modified":1604191413524},{"_id":"themes/hexo-theme-simperlog/source/css/_mixin.styl","hash":"67f774dea1113a3bd3e805a4c72d66c2d240ba1a","modified":1604191413533},{"_id":"themes/hexo-theme-simperlog/source/css/_variables.styl","hash":"b7f519b9be2a26eb63cd3c1c358c6cdc498fe4bd","modified":1604191413603},{"_id":"themes/hexo-theme-simperlog/source/css/style.styl","hash":"03287ff62f6e05632bdc8f8ac69db671ba920368","modified":1604191413623},{"_id":"themes/hexo-theme-simperlog/source/js/script.js","hash":"cf2630200b64667ef63ea84394bc8143aef79eb9","modified":1604191413632},{"_id":"themes/hexo-theme-simperlog/layout/_partial/post/gallery.ejs","hash":"1d436c8c2aebc0b95ae8ab89c7261ba735e3fcd4","modified":1604191413292},{"_id":"themes/hexo-theme-simperlog/layout/_partial/post/tag.ejs","hash":"a8f552e64ccb2079caf42cf536b8de371bb43b9d","modified":1604191413318},{"_id":"themes/hexo-theme-simperlog/layout/_partial/post/date.ejs","hash":"c334b04c440fad46619fff14422b6e7b57cae7c7","modified":1604191413282},{"_id":"themes/hexo-theme-simperlog/layout/_partial/post/title.ejs","hash":"139492c326292dc99b48d91dd861ae40c5d152cd","modified":1604191413335},{"_id":"themes/hexo-theme-simperlog/layout/_partial/post/share-box.ejs","hash":"2ceefbb62e410b3faed542b762256fbbe59d2b43","modified":1604191413309},{"_id":"themes/hexo-theme-simperlog/source/css/_partial/article.styl","hash":"943b4bc3f1a269bc5c753ae3381dd3e6f89de2c5","modified":1604191413544},{"_id":"themes/hexo-theme-simperlog/source/css/_partial/sidebar.styl","hash":"a839bd1abddbf526315f3767412ed8cc077556db","modified":1604191413595},{"_id":"themes/hexo-theme-simperlog/source/css/_partial/highlight.styl","hash":"0770d2d9f60f7fe8e1a2377560e709d0026fc7df","modified":1604191413575},{"_id":"themes/hexo-theme-simperlog/source/css/_partial/footer.styl","hash":"7a9d20837d24379b169e5996f6df7d23509c9abf","modified":1604191413559},{"_id":"themes/hexo-theme-simperlog/source/css/images/portrait.png","hash":"170fd7f1daddad952b42a9849d20c595bbbc0b8d","modified":1604191413615},{"_id":"themes/hexo-theme-simperlog/source/css/_partial/index.styl","hash":"ed1a775609814fe8514575589ee2e14955e13f79","modified":1604191413587},{"_id":"themes/hexo-theme-simperlog/source/css/_partial/header.styl","hash":"be86326bbf1fafda32ed514e29458765eb845393","modified":1604191413567},{"_id":"public/2020/11/01/hello-world/index.html","hash":"71c9586031fa21676b410fd8e722bd905b32f376","modified":1604191552394},{"_id":"public/archives/index.html","hash":"97cc12a6fe56142471f9f76e0e87e572299e51a7","modified":1604191552394},{"_id":"public/archives/2020/index.html","hash":"24869d60d6ede423d8ab5de8bcc76c4b592a1825","modified":1604191552394},{"_id":"public/archives/2020/11/index.html","hash":"035213616448558e89346b97cbd5d8605868ab0f","modified":1604191552394},{"_id":"public/index.html","hash":"f0db884e3dc5109ff406e6887a4340da6fc5b5da","modified":1604191552394},{"_id":"public/css/images/portrait.png","hash":"170fd7f1daddad952b42a9849d20c595bbbc0b8d","modified":1604191552394},{"_id":"public/css/style.css","hash":"108623dd4484683ad0fd1826e9aa9284724af56b","modified":1604191552394},{"_id":"public/js/script.js","hash":"cf2630200b64667ef63ea84394bc8143aef79eb9","modified":1604191552394},{"_id":"source/_posts/作业一.md","hash":"78f852951acd31b4193814b51a7f380037b82326","modified":1603513091352},{"_id":"source/_posts/作业二.md","hash":"edc8b9449eb207e4df96e44683d6ace63f9c89ee","modified":1604189917488},{"_id":"source/_posts/笔记.md","hash":"3c67f76eaa24edf1a8409be244dde607f5d0074a","modified":1603606088808},{"_id":"source/_posts/笔记2.md","hash":"b0c2bc9386763f1da16372d5578fe63648938d31","modified":1603621606814}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"### github page+hexo\n\n创建一个仓库，克隆到本地\n\n在github的setting中设置docs为根目录\n\n![image-20201025160826632](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201025160826632.png)\n\n\n\n删除项目中docs里的文件  rm -f *\n\n创建hexo init\n\n修改配置  \n\n```\npublic_dir：../docs\nurl: https://chronicch.github.io\nroot: /coral-blog\n```\n\nhexo generate\n\n\n\n### ES5\n\nes5中只有函数里面定义的变量才没有变量提升\n\n变量提升大于函数提升\n\n","source":"_posts/笔记2.md","raw":"### github page+hexo\n\n创建一个仓库，克隆到本地\n\n在github的setting中设置docs为根目录\n\n![image-20201025160826632](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201025160826632.png)\n\n\n\n删除项目中docs里的文件  rm -f *\n\n创建hexo init\n\n修改配置  \n\n```\npublic_dir：../docs\nurl: https://chronicch.github.io\nroot: /coral-blog\n```\n\nhexo generate\n\n\n\n### ES5\n\nes5中只有函数里面定义的变量才没有变量提升\n\n变量提升大于函数提升\n\n","slug":"笔记2","published":1,"date":"2020-11-01T00:47:05.408Z","updated":"2020-10-25T10:26:46.814Z","_id":"ckgye9w3e0000q0tz4yga22hx","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"github-page-hexo\"><a href=\"#github-page-hexo\" class=\"headerlink\" title=\"github page+hexo\"></a>github page+hexo</h3><p>创建一个仓库，克隆到本地</p>\n<p>在github的setting中设置docs为根目录</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201025160826632.png\" alt=\"image-20201025160826632\"></p>\n<p>删除项目中docs里的文件  rm -f *</p>\n<p>创建hexo init</p>\n<p>修改配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public_dir：..&#x2F;docs</span><br><span class=\"line\">url: https:&#x2F;&#x2F;chronicch.github.io</span><br><span class=\"line\">root: &#x2F;coral-blog</span><br></pre></td></tr></table></figure>\n\n<p>hexo generate</p>\n<h3 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h3><p>es5中只有函数里面定义的变量才没有变量提升</p>\n<p>变量提升大于函数提升</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"github-page-hexo\"><a href=\"#github-page-hexo\" class=\"headerlink\" title=\"github page+hexo\"></a>github page+hexo</h3><p>创建一个仓库，克隆到本地</p>\n<p>在github的setting中设置docs为根目录</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201025160826632.png\" alt=\"image-20201025160826632\"></p>\n<p>删除项目中docs里的文件  rm -f *</p>\n<p>创建hexo init</p>\n<p>修改配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public_dir：..&#x2F;docs</span><br><span class=\"line\">url: https:&#x2F;&#x2F;chronicch.github.io</span><br><span class=\"line\">root: &#x2F;coral-blog</span><br></pre></td></tr></table></figure>\n\n<p>hexo generate</p>\n<h3 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h3><p>es5中只有函数里面定义的变量才没有变量提升</p>\n<p>变量提升大于函数提升</p>\n"},{"_content":"### 作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\n\n\n\n---\n\n### 作业2: 了解XMLHttpRequest对象\n\n**XMLHttpRequest 对象用于在后台与服务器交换数据。**所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。\n\n作用：\n\n- 在不重新加载页面的情况下更新网页\n- 在页面已加载后从服务器请求数据\n- 在页面已加载后从服务器接收数据\n- 在后台向服务器发送数据\n\n> 2-1 XMLHttpRequest 对象的语法\n\n- 创建 XMLHttpRequest 对象的语法：\n\n`var xmlhttp=new XMLHttpRequest();`\n\n- 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：\n\n```\nvar xmlhttp;\n\nif (window.XMLHttpRequest){\n\n\t//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码\n\n    xmlhttp=new XMLHttpRequest();\n\n}else{\n\n    // IE6, IE5 浏览器执行代码\n\n    xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n}\n```\n\n> 2-2 请求和响应\n\n如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：\n\n`xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);`\n\n`xmlhttp.send();`\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png)\n\n> 2-2-1 GET还是POST？\n\n与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。\n\n然而，在以下情况中，请使用 POST 请求：\n\n- - 无法使用缓存文件（更新服务器上的文件或数据库）\n  - 向服务器发送大量数据（POST 没有数据量限制）\n  - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n> 2-2-2 服务器响应\n\n如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png)\n\n> 2-3 onreadystatechange 事件\n\n当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。\n\n下面是 XMLHttpRequest 对象的三个重要的属性：\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png)\n\n在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。\n\n当 readyState 等于 4 且状态为 200 时，表示响应已就绪：\n\n```\nxmlhttp.onreadystatechange=function(){\n   if (xmlhttp.readyState==4 && xmlhttp.status==200){\n        document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n}\n```\n\n*注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。*\n\n\n\n---\n\n### 作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\n\n> 3-1  prototype\n\n所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）\n\n例：\n\n```\nfunction Person(age) {\n    this.age = age       \n}\nPerson.prototype.name = 'kavin'\nvar person1 = new Person()\nvar person2 = new Person()\nconsole.log(person1.name) //kavin\nconsole.log(person2.name)  //kavin\n```\n\n原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。\n\n> 3-2  _proto__\n\n所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）\n\n```\nfunction Person() {\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n> 3-3 constructor\n\n每个原型都有一个constructor属性，指向该关联的构造函数。\n\n```\nfunction Person() {\n}\nconsole.log(Person===Person.prototype.constructor)  //true\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法,可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n//补充说明\nconsole.log(person.constructor === Person); // true\n\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n`person.constructor === Person.prototype.constructor`\n\n> 3-4 实例和原型\n\n 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n原型的原型：\n\n原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```\nvar obj = new Object();\nobj.name = 'Kevin'\nconsole.log(obj.name) // Kevin\n```\n\n> 3-5 原型链\n\n 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》\n\n```\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n\n所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n\n![](https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png)\n\n---\n\n### 作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\n\n#### 1.arguments对象\n\n**1-1 定义**\n\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是`arguments`对象的由来。\n\n`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\n```\nvar f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n}\n\nf(1, 2, 3)\n// 1\n// 2\n// 3\n```\n\n正常模式下，`arguments`对象可以在运行时修改。\n\n```\nvar f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 5\n```\n\n上面代码中，函数`f()`调用时传入的参数，在函数内部被修改成`3`和`2`。\n\n严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。\n\n```\nvar f = function(a, b) {\n  'use strict'; // 开启严格模式\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 2\n```\n\n上面代码中，函数体内是严格模式，这时修改`arguments`对象，不会影响到真实参数`a`和`b`。\n\n通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。\n\n```\nfunction f() {\n  return arguments.length;\n}\n\nf(1, 2, 3) // 3\nf(1) // 1\nf() // 0\n```\n\n**（2）与数组的关系**\n\n需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。\n\n如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。下面是两种常用的转换方法：`slice`方法和逐一填入新数组。\n\n```\nvar args = Array.prototype.slice.call(arguments);\n\n// 或者\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n```\n\n**（3）callee 属性**\n\n`arguments`对象带有一个`callee`属性，返回它所对应的原函数。\n\n```\nvar f = function () {\n  console.log(arguments.callee === f);\n}\n\nf() // true\n```\n\n可以通过`arguments.callee`，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n\n#### 2.break和continue\n\nbreak：跳出循环语句\n\ncontinue：跳过循环中的一个迭代\n\n#### 3.const、let、var\n\njs中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。\n\n区别：\n\n- const定义的变量不可以修改，而且必须初始化。\n  - const一般用来声明常量\n  - 与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义\n\n```\nconst b = 2;//正确\n// const b;//错误，必须初始化 \nconsole.log('函数外const定义b：' + b);//有输出值\n// b = 5;\n// console.log('函数外修改const定义b：' + b);//无法输出 \n```\n\n\n\n- var定义的变量可以修改，如果不初始化会输出undefined，不会报错。\n  - var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效\n  - 存在变量声明提前\n\n```\nvar a = 1;\n// var a;//不会报错\nconsole.log('函数外var定义a：' + a);//可以输出a=1\nfunction change(){\na = 4;\nconsole.log('函数内var定义a：' + a);//可以输出a=4\n} \nchange();\nconsole.log('函数调用后var定义a为函数内部修改值：' + a);//可以输出a=4\n```\n\n\n\n- let是块级作用域，函数内部使用let定义后，对函数外部无影响。\n  - 不存在声明提前\n  - 存在暂时性死区\n  - 不能重复定义。\n\n```\nlet c = 3;\nconsole.log('函数外let定义c：' + c);//输出c=3\nfunction change(){\nlet c = 6;\nconsole.log('函数内let定义c：' + c);//输出c=6\n} \nchange();\nconsole.log('函数调用后let定义c不受函数内部定义影响：' + c);//输出c=3\n\n//暂时性死区\nvar a=1；\nif(1){\n console.log(a); \n  let a=2;\n}\n```\n\n*暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。*\n\n#### 4.case、default\n\n case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch case 语句语法格式如下：\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n#### 5.try、catch、finally、throw\n\ntry/catch/finally 语句用于处理代码中可能出现的错误信息。\n\n**try**语句允许我们定义在执行时进行错误测试的代码块。\n\n**catch** 语句允许我们定义当 **try** 代码块发生错误时，所执行的代码块。\n\n**finally** 语句在 try 和 catch 之后无论有无异常都会执行。\n\n当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 [throw](https://www.runoob.com/jsref/jsref-throw.html) 语句 来创建自定义消息(抛出异常)。如果你将 **throw** 和 **try** 、 **catch**一起使用，就可以控制程序输出的错误信息。\n\n*注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。*\n\n```\ntry {\n    tryCode - 尝试执行代码块\n}\ncatch(err) {\n    catchCode - 捕获错误的代码块\n    \n    //例：\n    if(x == \"\") throw \"is Empty\";\n        if(isNaN(x)) throw \"not a number\";\n        if(x > 10) throw \"too high\";\n        if(x < 5) throw \"too low\";\n}\nfinally {\n    finallyCode - 无论 try / catch 结果如何都会执行的代码块\n}\n```\n\n#### 6.class\n\n在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。\n\nclass 的本质是 function。\n\n它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n\n#### 7.debugger\n\ndebugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。\n\n#### 8.delete\n\ndelete可以删除对象属性及变量。`delete obj.name;`\n\n*delete只能删除对象自己的属性，不能删除其原型链上的属性*\n\n#### 9.instanceof\n\n\n\n---\n\n### 作业5：把其他同学class2的作业阅读学习一遍\n\n\n\n#### 1.学习AJAX是什么，AJAX实现方法\n\n**1-1. 什么是AJAX？**\n\n- Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。\n- Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。\n- Ajax 是一种用于创建快速动态网页的技术。\n- Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n- 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n**1-2. AJAX工作原理**\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png)\n\n**1-3. AJAX是基于现有的Internet标准**\n\n- AJAX是基于现有的Internet标准，并且联合使用它们：\n\n- - XMLHttpRequest 对象 (异步的与服务器交换数据)\n  - JavaScript/DOM (信息显示/交互)\n  - CSS (给数据定义样式)\n  - XML (作为转换数据的格式)\n\n- AJAX应用程序与浏览器和平台无关的！\n\n- Ajax编程步骤：\n  - 创建XMLHttpRequest对象。\n  - 设置请求方式。\n  - 调用回调函数。\n  - 发送请求。\n\n**1-4.原生JavaScript实现AJAX**\n\nXMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。\n\n例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>原生js实现ajax</title>\n    <script>\n        //定义方法\n        function fun() {\n            //发送异步请求\n            //1.创建核心对象\n            var xmlhttp;\n            if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n                xmlhttp=new XMLHttpRequest();\n            }else{// code for IE6, IE5\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            //2.建立连接\n            xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);\n\n            //3.发送请求\n            xmlhttp.send();\n\n            //4.接收并处理服务器的响应结果\n            //获取方式：xmlhttp.responseText\n\n            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange\n            xmlhttp.onreadystatechange=function(){\n                //判断readyState是否为4，判断status响应状态码是否为200\n                if (xmlhttp.readyState==4 && xmlhttp.status==200){\n                    var responseText = xmlhttp.responseText;\n                    alert(responseText);\n                }\n            }\n        }\n    </script>\n</head>\n<body>\n    <input type=\"button\" value=\"发送异步请求\" onclick=\"fun()\">\n    <input>\n</body>\n</html>\n```\n\n\n\n#### 2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\n\n**2-1 AMD**","source":"_posts/作业二.md","raw":"### 作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\n\n\n\n---\n\n### 作业2: 了解XMLHttpRequest对象\n\n**XMLHttpRequest 对象用于在后台与服务器交换数据。**所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。\n\n作用：\n\n- 在不重新加载页面的情况下更新网页\n- 在页面已加载后从服务器请求数据\n- 在页面已加载后从服务器接收数据\n- 在后台向服务器发送数据\n\n> 2-1 XMLHttpRequest 对象的语法\n\n- 创建 XMLHttpRequest 对象的语法：\n\n`var xmlhttp=new XMLHttpRequest();`\n\n- 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：\n\n```\nvar xmlhttp;\n\nif (window.XMLHttpRequest){\n\n\t//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码\n\n    xmlhttp=new XMLHttpRequest();\n\n}else{\n\n    // IE6, IE5 浏览器执行代码\n\n    xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n}\n```\n\n> 2-2 请求和响应\n\n如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：\n\n`xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);`\n\n`xmlhttp.send();`\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png)\n\n> 2-2-1 GET还是POST？\n\n与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。\n\n然而，在以下情况中，请使用 POST 请求：\n\n- - 无法使用缓存文件（更新服务器上的文件或数据库）\n  - 向服务器发送大量数据（POST 没有数据量限制）\n  - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n> 2-2-2 服务器响应\n\n如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png)\n\n> 2-3 onreadystatechange 事件\n\n当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。\n\n下面是 XMLHttpRequest 对象的三个重要的属性：\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png)\n\n在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。\n\n当 readyState 等于 4 且状态为 200 时，表示响应已就绪：\n\n```\nxmlhttp.onreadystatechange=function(){\n   if (xmlhttp.readyState==4 && xmlhttp.status==200){\n        document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n}\n```\n\n*注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。*\n\n\n\n---\n\n### 作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\n\n> 3-1  prototype\n\n所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）\n\n例：\n\n```\nfunction Person(age) {\n    this.age = age       \n}\nPerson.prototype.name = 'kavin'\nvar person1 = new Person()\nvar person2 = new Person()\nconsole.log(person1.name) //kavin\nconsole.log(person2.name)  //kavin\n```\n\n原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。\n\n> 3-2  _proto__\n\n所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）\n\n```\nfunction Person() {\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n> 3-3 constructor\n\n每个原型都有一个constructor属性，指向该关联的构造函数。\n\n```\nfunction Person() {\n}\nconsole.log(Person===Person.prototype.constructor)  //true\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法,可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n//补充说明\nconsole.log(person.constructor === Person); // true\n\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n`person.constructor === Person.prototype.constructor`\n\n> 3-4 实例和原型\n\n 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n原型的原型：\n\n原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```\nvar obj = new Object();\nobj.name = 'Kevin'\nconsole.log(obj.name) // Kevin\n```\n\n> 3-5 原型链\n\n 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》\n\n```\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n\n所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n\n![](https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png)\n\n---\n\n### 作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\n\n#### 1.arguments对象\n\n**1-1 定义**\n\n由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是`arguments`对象的由来。\n\n`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\n```\nvar f = function (one) {\n  console.log(arguments[0]);\n  console.log(arguments[1]);\n  console.log(arguments[2]);\n}\n\nf(1, 2, 3)\n// 1\n// 2\n// 3\n```\n\n正常模式下，`arguments`对象可以在运行时修改。\n\n```\nvar f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 5\n```\n\n上面代码中，函数`f()`调用时传入的参数，在函数内部被修改成`3`和`2`。\n\n严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。\n\n```\nvar f = function(a, b) {\n  'use strict'; // 开启严格模式\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1) // 2\n```\n\n上面代码中，函数体内是严格模式，这时修改`arguments`对象，不会影响到真实参数`a`和`b`。\n\n通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。\n\n```\nfunction f() {\n  return arguments.length;\n}\n\nf(1, 2, 3) // 3\nf(1) // 1\nf() // 0\n```\n\n**（2）与数组的关系**\n\n需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。\n\n如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。下面是两种常用的转换方法：`slice`方法和逐一填入新数组。\n\n```\nvar args = Array.prototype.slice.call(arguments);\n\n// 或者\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n```\n\n**（3）callee 属性**\n\n`arguments`对象带有一个`callee`属性，返回它所对应的原函数。\n\n```\nvar f = function () {\n  console.log(arguments.callee === f);\n}\n\nf() // true\n```\n\n可以通过`arguments.callee`，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n\n#### 2.break和continue\n\nbreak：跳出循环语句\n\ncontinue：跳过循环中的一个迭代\n\n#### 3.const、let、var\n\njs中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。\n\n区别：\n\n- const定义的变量不可以修改，而且必须初始化。\n  - const一般用来声明常量\n  - 与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义\n\n```\nconst b = 2;//正确\n// const b;//错误，必须初始化 \nconsole.log('函数外const定义b：' + b);//有输出值\n// b = 5;\n// console.log('函数外修改const定义b：' + b);//无法输出 \n```\n\n\n\n- var定义的变量可以修改，如果不初始化会输出undefined，不会报错。\n  - var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效\n  - 存在变量声明提前\n\n```\nvar a = 1;\n// var a;//不会报错\nconsole.log('函数外var定义a：' + a);//可以输出a=1\nfunction change(){\na = 4;\nconsole.log('函数内var定义a：' + a);//可以输出a=4\n} \nchange();\nconsole.log('函数调用后var定义a为函数内部修改值：' + a);//可以输出a=4\n```\n\n\n\n- let是块级作用域，函数内部使用let定义后，对函数外部无影响。\n  - 不存在声明提前\n  - 存在暂时性死区\n  - 不能重复定义。\n\n```\nlet c = 3;\nconsole.log('函数外let定义c：' + c);//输出c=3\nfunction change(){\nlet c = 6;\nconsole.log('函数内let定义c：' + c);//输出c=6\n} \nchange();\nconsole.log('函数调用后let定义c不受函数内部定义影响：' + c);//输出c=3\n\n//暂时性死区\nvar a=1；\nif(1){\n console.log(a); \n  let a=2;\n}\n```\n\n*暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。*\n\n#### 4.case、default\n\n case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch case 语句语法格式如下：\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n#### 5.try、catch、finally、throw\n\ntry/catch/finally 语句用于处理代码中可能出现的错误信息。\n\n**try**语句允许我们定义在执行时进行错误测试的代码块。\n\n**catch** 语句允许我们定义当 **try** 代码块发生错误时，所执行的代码块。\n\n**finally** 语句在 try 和 catch 之后无论有无异常都会执行。\n\n当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 [throw](https://www.runoob.com/jsref/jsref-throw.html) 语句 来创建自定义消息(抛出异常)。如果你将 **throw** 和 **try** 、 **catch**一起使用，就可以控制程序输出的错误信息。\n\n*注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。*\n\n```\ntry {\n    tryCode - 尝试执行代码块\n}\ncatch(err) {\n    catchCode - 捕获错误的代码块\n    \n    //例：\n    if(x == \"\") throw \"is Empty\";\n        if(isNaN(x)) throw \"not a number\";\n        if(x > 10) throw \"too high\";\n        if(x < 5) throw \"too low\";\n}\nfinally {\n    finallyCode - 无论 try / catch 结果如何都会执行的代码块\n}\n```\n\n#### 6.class\n\n在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。\n\nclass 的本质是 function。\n\n它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n\n#### 7.debugger\n\ndebugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。\n\n#### 8.delete\n\ndelete可以删除对象属性及变量。`delete obj.name;`\n\n*delete只能删除对象自己的属性，不能删除其原型链上的属性*\n\n#### 9.instanceof\n\n\n\n---\n\n### 作业5：把其他同学class2的作业阅读学习一遍\n\n\n\n#### 1.学习AJAX是什么，AJAX实现方法\n\n**1-1. 什么是AJAX？**\n\n- Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。\n- Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。\n- Ajax 是一种用于创建快速动态网页的技术。\n- Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n- 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n**1-2. AJAX工作原理**\n\n![img](F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png)\n\n**1-3. AJAX是基于现有的Internet标准**\n\n- AJAX是基于现有的Internet标准，并且联合使用它们：\n\n- - XMLHttpRequest 对象 (异步的与服务器交换数据)\n  - JavaScript/DOM (信息显示/交互)\n  - CSS (给数据定义样式)\n  - XML (作为转换数据的格式)\n\n- AJAX应用程序与浏览器和平台无关的！\n\n- Ajax编程步骤：\n  - 创建XMLHttpRequest对象。\n  - 设置请求方式。\n  - 调用回调函数。\n  - 发送请求。\n\n**1-4.原生JavaScript实现AJAX**\n\nXMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。\n\n例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>原生js实现ajax</title>\n    <script>\n        //定义方法\n        function fun() {\n            //发送异步请求\n            //1.创建核心对象\n            var xmlhttp;\n            if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n                xmlhttp=new XMLHttpRequest();\n            }else{// code for IE6, IE5\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            //2.建立连接\n            xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);\n\n            //3.发送请求\n            xmlhttp.send();\n\n            //4.接收并处理服务器的响应结果\n            //获取方式：xmlhttp.responseText\n\n            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange\n            xmlhttp.onreadystatechange=function(){\n                //判断readyState是否为4，判断status响应状态码是否为200\n                if (xmlhttp.readyState==4 && xmlhttp.status==200){\n                    var responseText = xmlhttp.responseText;\n                    alert(responseText);\n                }\n            }\n        }\n    </script>\n</head>\n<body>\n    <input type=\"button\" value=\"发送异步请求\" onclick=\"fun()\">\n    <input>\n</body>\n</html>\n```\n\n\n\n#### 2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\n\n**2-1 AMD**","slug":"作业二","published":1,"date":"2020-11-01T00:47:05.500Z","updated":"2020-11-01T00:18:37.488Z","_id":"ckgye9w6a0001q0tz7ot65jeu","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"><a href=\"#作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\" class=\"headerlink\" title=\"作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"></a>作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题</h3><hr>\n<h3 id=\"作业2-了解XMLHttpRequest对象\"><a href=\"#作业2-了解XMLHttpRequest对象\" class=\"headerlink\" title=\"作业2: 了解XMLHttpRequest对象\"></a>作业2: 了解XMLHttpRequest对象</h3><p><strong>XMLHttpRequest 对象用于在后台与服务器交换数据。</strong>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>\n<p>作用：</p>\n<ul>\n<li>在不重新加载页面的情况下更新网页</li>\n<li>在页面已加载后从服务器请求数据</li>\n<li>在页面已加载后从服务器接收数据</li>\n<li>在后台向服务器发送数据</li>\n</ul>\n<blockquote>\n<p>2-1 XMLHttpRequest 对象的语法</p>\n</blockquote>\n<ul>\n<li>创建 XMLHttpRequest 对象的语法：</li>\n</ul>\n<p><code>var xmlhttp=new XMLHttpRequest();</code></p>\n<ul>\n<li>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\"></span><br><span class=\"line\">if (window.XMLHttpRequest)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2-2 请求和响应</p>\n</blockquote>\n<p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>\n<p><code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);</code></p>\n<p><code>xmlhttp.send();</code></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-2-1 GET还是POST？</p>\n</blockquote>\n<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>\n<p>然而，在以下情况中，请使用 POST 请求：</p>\n<ul>\n<li><ul>\n<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>\n<li>向服务器发送大量数据（POST 没有数据量限制）</li>\n<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2-2 服务器响应</p>\n</blockquote>\n<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-3 onreadystatechange 事件</p>\n</blockquote>\n<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。</p>\n<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png\" alt=\"img\"></p>\n<p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>\n<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">   if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">        document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</em></p>\n<hr>\n<h3 id=\"作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\"><a href=\"#作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\" class=\"headerlink\" title=\"作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\"></a>作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链</h3><blockquote>\n<p>3-1  prototype</p>\n</blockquote>\n<p>所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(age) &#123;</span><br><span class=\"line\">    this.age &#x3D; age       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name &#x3D; &#39;kavin&#39;</span><br><span class=\"line\">var person1 &#x3D; new Person()</span><br><span class=\"line\">var person2 &#x3D; new Person()</span><br><span class=\"line\">console.log(person1.name) &#x2F;&#x2F;kavin</span><br><span class=\"line\">console.log(person2.name)  &#x2F;&#x2F;kavin</span><br></pre></td></tr></table></figure>\n\n<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>\n<blockquote>\n<p>3-2  _proto__</p>\n</blockquote>\n<p>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-3 constructor</p>\n</blockquote>\n<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Person&#x3D;&#x3D;&#x3D;Person.prototype.constructor)  &#x2F;&#x2F;true</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class=\"line\">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F;补充说明</span><br><span class=\"line\">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>\n<p><code>person.constructor === Person.prototype.constructor</code></p>\n<blockquote>\n<p>3-4 实例和原型</p>\n</blockquote>\n<p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>\n<p>原型的原型：</p>\n<p>原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; new Object();</span><br><span class=\"line\">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class=\"line\">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-5 原型链</p>\n</blockquote>\n<p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>\n<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>\n<p>最后一张关系图也可以更新为：</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png\"></p>\n<hr>\n<h3 id=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"><a href=\"#作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\" class=\"headerlink\" title=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"></a>作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</h3><h4 id=\"1-arguments对象\"><a href=\"#1-arguments对象\" class=\"headerlink\" title=\"1.arguments对象\"></a>1.arguments对象</h4><p><strong>1-1 定义</strong></p>\n<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>\n<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function (one) &#123;</span><br><span class=\"line\">  console.log(arguments[0]);</span><br><span class=\"line\">  console.log(arguments[1]);</span><br><span class=\"line\">  console.log(arguments[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3)</span><br><span class=\"line\">&#x2F;&#x2F; 1</span><br><span class=\"line\">&#x2F;&#x2F; 2</span><br><span class=\"line\">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>\n<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  &#39;use strict&#39;; &#x2F;&#x2F; 开启严格模式</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>\n<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  return arguments.length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3) &#x2F;&#x2F; 3</span><br><span class=\"line\">f(1) &#x2F;&#x2F; 1</span><br><span class=\"line\">f() &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）与数组的关系</strong></p>\n<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>\n<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者</span><br><span class=\"line\">var args &#x3D; [];</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"line\">  args.push(arguments[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）callee 属性</strong></p>\n<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function () &#123;</span><br><span class=\"line\">  console.log(arguments.callee &#x3D;&#x3D;&#x3D; f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>\n<h4 id=\"2-break和continue\"><a href=\"#2-break和continue\" class=\"headerlink\" title=\"2.break和continue\"></a>2.break和continue</h4><p>break：跳出循环语句</p>\n<p>continue：跳过循环中的一个迭代</p>\n<h4 id=\"3-const、let、var\"><a href=\"#3-const、let、var\" class=\"headerlink\" title=\"3.const、let、var\"></a>3.const、let、var</h4><p>js中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。</p>\n<p>区别：</p>\n<ul>\n<li>const定义的变量不可以修改，而且必须初始化。<ul>\n<li>const一般用来声明常量</li>\n<li>与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b &#x3D; 2;&#x2F;&#x2F;正确</span><br><span class=\"line\">&#x2F;&#x2F; const b;&#x2F;&#x2F;错误，必须初始化 </span><br><span class=\"line\">console.log(&#39;函数外const定义b：&#39; + b);&#x2F;&#x2F;有输出值</span><br><span class=\"line\">&#x2F;&#x2F; b &#x3D; 5;</span><br><span class=\"line\">&#x2F;&#x2F; console.log(&#39;函数外修改const定义b：&#39; + b);&#x2F;&#x2F;无法输出 </span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。<ul>\n<li>var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效</li>\n<li>存在变量声明提前</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F; var a;&#x2F;&#x2F;不会报错</span><br><span class=\"line\">console.log(&#39;函数外var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;1</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">a &#x3D; 4;</span><br><span class=\"line\">console.log(&#39;函数内var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后var定义a为函数内部修改值：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。<ul>\n<li>不存在声明提前</li>\n<li>存在暂时性死区</li>\n<li>不能重复定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c &#x3D; 3;</span><br><span class=\"line\">console.log(&#39;函数外let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">let c &#x3D; 6;</span><br><span class=\"line\">console.log(&#39;函数内let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;6</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后let定义c不受函数内部定义影响：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;暂时性死区</span><br><span class=\"line\">var a&#x3D;1；</span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\"> console.log(a); </span><br><span class=\"line\">  let a&#x3D;2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</em></p>\n<h4 id=\"4-case、default\"><a href=\"#4-case、default\" class=\"headerlink\" title=\"4.case、default\"></a>4.case、default</h4><p> case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>\n<p>switch case 语句语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(expression)&#123;</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    &#x2F;&#x2F;你可以有任意数量的case语句</span><br><span class=\"line\">    default : &#x2F;&#x2F;可选</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-try、catch、finally、throw\"><a href=\"#5-try、catch、finally、throw\" class=\"headerlink\" title=\"5.try、catch、finally、throw\"></a>5.try、catch、finally、throw</h4><p>try/catch/finally 语句用于处理代码中可能出现的错误信息。</p>\n<p><strong>try</strong>语句允许我们定义在执行时进行错误测试的代码块。</p>\n<p><strong>catch</strong> 语句允许我们定义当 <strong>try</strong> 代码块发生错误时，所执行的代码块。</p>\n<p><strong>finally</strong> 语句在 try 和 catch 之后无论有无异常都会执行。</p>\n<p>当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 <a href=\"https://www.runoob.com/jsref/jsref-throw.html\">throw</a> 语句 来创建自定义消息(抛出异常)。如果你将 <strong>throw</strong> 和 <strong>try</strong> 、 <strong>catch</strong>一起使用，就可以控制程序输出的错误信息。</p>\n<p><em>注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    tryCode - 尝试执行代码块</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch(err) &#123;</span><br><span class=\"line\">    catchCode - 捕获错误的代码块</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;例：</span><br><span class=\"line\">    if(x &#x3D;&#x3D; &quot;&quot;) throw &quot;is Empty&quot;;</span><br><span class=\"line\">        if(isNaN(x)) throw &quot;not a number&quot;;</span><br><span class=\"line\">        if(x &gt; 10) throw &quot;too high&quot;;</span><br><span class=\"line\">        if(x &lt; 5) throw &quot;too low&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally &#123;</span><br><span class=\"line\">    finallyCode - 无论 try &#x2F; catch 结果如何都会执行的代码块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-class\"><a href=\"#6-class\" class=\"headerlink\" title=\"6.class\"></a>6.class</h4><p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。</p>\n<p>class 的本质是 function。</p>\n<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h4 id=\"7-debugger\"><a href=\"#7-debugger\" class=\"headerlink\" title=\"7.debugger\"></a>7.debugger</h4><p>debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。</p>\n<h4 id=\"8-delete\"><a href=\"#8-delete\" class=\"headerlink\" title=\"8.delete\"></a>8.delete</h4><p>delete可以删除对象属性及变量。<code>delete obj.name;</code></p>\n<p><em>delete只能删除对象自己的属性，不能删除其原型链上的属性</em></p>\n<h4 id=\"9-instanceof\"><a href=\"#9-instanceof\" class=\"headerlink\" title=\"9.instanceof\"></a>9.instanceof</h4><hr>\n<h3 id=\"作业5：把其他同学class2的作业阅读学习一遍\"><a href=\"#作业5：把其他同学class2的作业阅读学习一遍\" class=\"headerlink\" title=\"作业5：把其他同学class2的作业阅读学习一遍\"></a>作业5：把其他同学class2的作业阅读学习一遍</h3><h4 id=\"1-学习AJAX是什么，AJAX实现方法\"><a href=\"#1-学习AJAX是什么，AJAX实现方法\" class=\"headerlink\" title=\"1.学习AJAX是什么，AJAX实现方法\"></a>1.学习AJAX是什么，AJAX实现方法</h4><p><strong>1-1. 什么是AJAX？</strong></p>\n<ul>\n<li>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</li>\n<li>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</li>\n<li>Ajax 是一种用于创建快速动态网页的技术。</li>\n<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>\n</ul>\n<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<ul>\n<li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>\n</ul>\n<p><strong>1-2. AJAX工作原理</strong></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png\" alt=\"img\"></p>\n<p><strong>1-3. AJAX是基于现有的Internet标准</strong></p>\n<ul>\n<li><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p>\n</li>\n<li><ul>\n<li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li>\n<li>JavaScript/DOM (信息显示/交互)</li>\n<li>CSS (给数据定义样式)</li>\n<li>XML (作为转换数据的格式)</li>\n</ul>\n</li>\n<li><p>AJAX应用程序与浏览器和平台无关的！</p>\n</li>\n<li><p>Ajax编程步骤：</p>\n<ul>\n<li>创建XMLHttpRequest对象。</li>\n<li>设置请求方式。</li>\n<li>调用回调函数。</li>\n<li>发送请求。</li>\n</ul>\n</li>\n</ul>\n<p><strong>1-4.原生JavaScript实现AJAX</strong></p>\n<p>XMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;原生js实现ajax&lt;&#x2F;title&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        &#x2F;&#x2F;定义方法</span><br><span class=\"line\">        function fun() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;发送异步请求</span><br><span class=\"line\">            &#x2F;&#x2F;1.创建核心对象</span><br><span class=\"line\">            var xmlhttp;</span><br><span class=\"line\">            if (window.XMLHttpRequest)&#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class=\"line\">                xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">            &#125;else&#123;&#x2F;&#x2F; code for IE6, IE5</span><br><span class=\"line\">                xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;2.建立连接</span><br><span class=\"line\">            xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username&#x3D;tom&quot;,true);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;3.发送请求</span><br><span class=\"line\">            xmlhttp.send();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;4.接收并处理服务器的响应结果</span><br><span class=\"line\">            &#x2F;&#x2F;获取方式：xmlhttp.responseText</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange</span><br><span class=\"line\">            xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;判断readyState是否为4，判断status响应状态码是否为200</span><br><span class=\"line\">                if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">                    var responseText &#x3D; xmlhttp.responseText;</span><br><span class=\"line\">                    alert(responseText);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;发送异步请求&quot; onclick&#x3D;&quot;fun()&quot;&gt;</span><br><span class=\"line\">    &lt;input&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\"><a href=\"#2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\" class=\"headerlink\" title=\"2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\"></a>2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD</h4><p><strong>2-1 AMD</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"><a href=\"#作业1-把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\" class=\"headerlink\" title=\"作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题\"></a>作业1: 把之前的作业分类成多篇文章同步在hexo中；为hexo更改一个好看的主题</h3><hr>\n<h3 id=\"作业2-了解XMLHttpRequest对象\"><a href=\"#作业2-了解XMLHttpRequest对象\" class=\"headerlink\" title=\"作业2: 了解XMLHttpRequest对象\"></a>作业2: 了解XMLHttpRequest对象</h3><p><strong>XMLHttpRequest 对象用于在后台与服务器交换数据。</strong>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>\n<p>作用：</p>\n<ul>\n<li>在不重新加载页面的情况下更新网页</li>\n<li>在页面已加载后从服务器请求数据</li>\n<li>在页面已加载后从服务器接收数据</li>\n<li>在后台向服务器发送数据</li>\n</ul>\n<blockquote>\n<p>2-1 XMLHttpRequest 对象的语法</p>\n</blockquote>\n<ul>\n<li>创建 XMLHttpRequest 对象的语法：</li>\n</ul>\n<p><code>var xmlhttp=new XMLHttpRequest();</code></p>\n<ul>\n<li>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\"></span><br><span class=\"line\">if (window.XMLHttpRequest)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>2-2 请求和响应</p>\n</blockquote>\n<p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>\n<p><code>xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true);</code></p>\n<p><code>xmlhttp.send();</code></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\15d6fd38ca5e44dcb26f9227bff0337b\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-2-1 GET还是POST？</p>\n</blockquote>\n<p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p>\n<p>然而，在以下情况中，请使用 POST 请求：</p>\n<ul>\n<li><ul>\n<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>\n<li>向服务器发送大量数据（POST 没有数据量限制）</li>\n<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2-2 服务器响应</p>\n</blockquote>\n<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\8702116698b3429ea60c5b154a1baf0f\\clipboard.png\" alt=\"img\"></p>\n<blockquote>\n<p>2-3 onreadystatechange 事件</p>\n</blockquote>\n<p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。</p>\n<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\edee59fe2c9d461b8deb8241a4121df6\\clipboard.png\" alt=\"img\"></p>\n<p>在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>\n<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">   if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">        document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。</em></p>\n<hr>\n<h3 id=\"作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\"><a href=\"#作业3-尽自己可能找到所有和JavaScript原型链有关的知识点-试图掌握JavaScript原型链\" class=\"headerlink\" title=\"作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链\"></a>作业3: 尽自己可能找到所有和JavaScript原型链有关的知识点 试图掌握JavaScript原型链</h3><blockquote>\n<p>3-1  prototype</p>\n</blockquote>\n<p>所有函数都有一个prototype属性，这个属性指向函数的原型对象。（显式原型）</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(age) &#123;</span><br><span class=\"line\">    this.age &#x3D; age       </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.name &#x3D; &#39;kavin&#39;</span><br><span class=\"line\">var person1 &#x3D; new Person()</span><br><span class=\"line\">var person2 &#x3D; new Person()</span><br><span class=\"line\">console.log(person1.name) &#x2F;&#x2F;kavin</span><br><span class=\"line\">console.log(person2.name)  &#x2F;&#x2F;kavin</span><br></pre></td></tr></table></figure>\n\n<p>原型的概念：每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性。</p>\n<blockquote>\n<p>3-2  _proto__</p>\n</blockquote>\n<p>所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-3 constructor</p>\n</blockquote>\n<p>每个原型都有一个constructor属性，指向该关联的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Person&#x3D;&#x3D;&#x3D;Person.prototype.constructor)  &#x2F;&#x2F;true</span><br><span class=\"line\">var person &#x3D; new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person.__proto__ &#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(Person.prototype.constructor &#x3D;&#x3D; Person) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F; 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class=\"line\">console.log(Object.getPrototypeOf(person) &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true</span><br><span class=\"line\">&#x2F;&#x2F;补充说明</span><br><span class=\"line\">console.log(person.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>\n<p><code>person.constructor === Person.prototype.constructor</code></p>\n<blockquote>\n<p>3-4 实例和原型</p>\n</blockquote>\n<p> 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>\n<p>原型的原型：</p>\n<p>原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; new Object();</span><br><span class=\"line\">obj.name &#x3D; &#39;Kevin&#39;</span><br><span class=\"line\">console.log(obj.name) &#x2F;&#x2F; Kevin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>3-5 原型链</p>\n</blockquote>\n<p> 简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>\n<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>\n<p>最后一张关系图也可以更新为：</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/850375/201907/850375-20190708153139577-2105652554.png\"></p>\n<hr>\n<h3 id=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"><a href=\"#作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\" class=\"headerlink\" title=\"作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。\"></a>作业4：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</h3><h4 id=\"1-arguments对象\"><a href=\"#1-arguments对象\" class=\"headerlink\" title=\"1.arguments对象\"></a>1.arguments对象</h4><p><strong>1-1 定义</strong></p>\n<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>\n<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function (one) &#123;</span><br><span class=\"line\">  console.log(arguments[0]);</span><br><span class=\"line\">  console.log(arguments[1]);</span><br><span class=\"line\">  console.log(arguments[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3)</span><br><span class=\"line\">&#x2F;&#x2F; 1</span><br><span class=\"line\">&#x2F;&#x2F; 2</span><br><span class=\"line\">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>\n<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function(a, b) &#123;</span><br><span class=\"line\">  &#39;use strict&#39;; &#x2F;&#x2F; 开启严格模式</span><br><span class=\"line\">  arguments[0] &#x3D; 3;</span><br><span class=\"line\">  arguments[1] &#x3D; 2;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>\n<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  return arguments.length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(1, 2, 3) &#x2F;&#x2F; 3</span><br><span class=\"line\">f(1) &#x2F;&#x2F; 1</span><br><span class=\"line\">f() &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）与数组的关系</strong></p>\n<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>\n<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 或者</span><br><span class=\"line\">var args &#x3D; [];</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"line\">  args.push(arguments[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>（3）callee 属性</strong></p>\n<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; function () &#123;</span><br><span class=\"line\">  console.log(arguments.callee &#x3D;&#x3D;&#x3D; f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>\n<h4 id=\"2-break和continue\"><a href=\"#2-break和continue\" class=\"headerlink\" title=\"2.break和continue\"></a>2.break和continue</h4><p>break：跳出循环语句</p>\n<p>continue：跳过循环中的一个迭代</p>\n<h4 id=\"3-const、let、var\"><a href=\"#3-const、let、var\" class=\"headerlink\" title=\"3.const、let、var\"></a>3.const、let、var</h4><p>js中三种定义变量的方式const， var， let。let是es6新增的声明变量的方式。</p>\n<p>区别：</p>\n<ul>\n<li>const定义的变量不可以修改，而且必须初始化。<ul>\n<li>const一般用来声明常量</li>\n<li>与let一样都说块级作用域，存在暂时性死区，不存在变量声明提前，不允许重复定义</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const b &#x3D; 2;&#x2F;&#x2F;正确</span><br><span class=\"line\">&#x2F;&#x2F; const b;&#x2F;&#x2F;错误，必须初始化 </span><br><span class=\"line\">console.log(&#39;函数外const定义b：&#39; + b);&#x2F;&#x2F;有输出值</span><br><span class=\"line\">&#x2F;&#x2F; b &#x3D; 5;</span><br><span class=\"line\">&#x2F;&#x2F; console.log(&#39;函数外修改const定义b：&#39; + b);&#x2F;&#x2F;无法输出 </span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。<ul>\n<li>var的作用域是函数作用域，在一个函数内利用var声明一个变量，则这个变量只在这个函数内有效</li>\n<li>存在变量声明提前</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F; var a;&#x2F;&#x2F;不会报错</span><br><span class=\"line\">console.log(&#39;函数外var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;1</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">a &#x3D; 4;</span><br><span class=\"line\">console.log(&#39;函数内var定义a：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后var定义a为函数内部修改值：&#39; + a);&#x2F;&#x2F;可以输出a&#x3D;4</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>let是块级作用域，函数内部使用let定义后，对函数外部无影响。<ul>\n<li>不存在声明提前</li>\n<li>存在暂时性死区</li>\n<li>不能重复定义。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c &#x3D; 3;</span><br><span class=\"line\">console.log(&#39;函数外let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\">function change()&#123;</span><br><span class=\"line\">let c &#x3D; 6;</span><br><span class=\"line\">console.log(&#39;函数内let定义c：&#39; + c);&#x2F;&#x2F;输出c&#x3D;6</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">change();</span><br><span class=\"line\">console.log(&#39;函数调用后let定义c不受函数内部定义影响：&#39; + c);&#x2F;&#x2F;输出c&#x3D;3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;暂时性死区</span><br><span class=\"line\">var a&#x3D;1；</span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\"> console.log(a); </span><br><span class=\"line\">  let a&#x3D;2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</em></p>\n<h4 id=\"4-case、default\"><a href=\"#4-case、default\" class=\"headerlink\" title=\"4.case、default\"></a>4.case、default</h4><p> case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>\n<p>switch case 语句语法格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(expression)&#123;</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">       break; &#x2F;&#x2F;可选</span><br><span class=\"line\">    &#x2F;&#x2F;你可以有任意数量的case语句</span><br><span class=\"line\">    default : &#x2F;&#x2F;可选</span><br><span class=\"line\">       &#x2F;&#x2F;语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-try、catch、finally、throw\"><a href=\"#5-try、catch、finally、throw\" class=\"headerlink\" title=\"5.try、catch、finally、throw\"></a>5.try、catch、finally、throw</h4><p>try/catch/finally 语句用于处理代码中可能出现的错误信息。</p>\n<p><strong>try</strong>语句允许我们定义在执行时进行错误测试的代码块。</p>\n<p><strong>catch</strong> 语句允许我们定义当 <strong>try</strong> 代码块发生错误时，所执行的代码块。</p>\n<p><strong>finally</strong> 语句在 try 和 catch 之后无论有无异常都会执行。</p>\n<p>当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 <a href=\"https://www.runoob.com/jsref/jsref-throw.html\">throw</a> 语句 来创建自定义消息(抛出异常)。如果你将 <strong>throw</strong> 和 <strong>try</strong> 、 <strong>catch</strong>一起使用，就可以控制程序输出的错误信息。</p>\n<p><em>注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    tryCode - 尝试执行代码块</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">catch(err) &#123;</span><br><span class=\"line\">    catchCode - 捕获错误的代码块</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;例：</span><br><span class=\"line\">    if(x &#x3D;&#x3D; &quot;&quot;) throw &quot;is Empty&quot;;</span><br><span class=\"line\">        if(isNaN(x)) throw &quot;not a number&quot;;</span><br><span class=\"line\">        if(x &gt; 10) throw &quot;too high&quot;;</span><br><span class=\"line\">        if(x &lt; 5) throw &quot;too low&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally &#123;</span><br><span class=\"line\">    finallyCode - 无论 try &#x2F; catch 结果如何都会执行的代码块</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-class\"><a href=\"#6-class\" class=\"headerlink\" title=\"6.class\"></a>6.class</h4><p>在ES6中，class (类)作为对象的模板被引入，可以通过 class 声明创建一个基于原型继承的具有给定名称的新类。</p>\n<p>class 的本质是 function。</p>\n<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h4 id=\"7-debugger\"><a href=\"#7-debugger\" class=\"headerlink\" title=\"7.debugger\"></a>7.debugger</h4><p>debugger 语句用于停止执行 JavaScript，并调用 (如果可用) 调试函数。使用 debugger 语句类似于在代码中设置断点。</p>\n<h4 id=\"8-delete\"><a href=\"#8-delete\" class=\"headerlink\" title=\"8.delete\"></a>8.delete</h4><p>delete可以删除对象属性及变量。<code>delete obj.name;</code></p>\n<p><em>delete只能删除对象自己的属性，不能删除其原型链上的属性</em></p>\n<h4 id=\"9-instanceof\"><a href=\"#9-instanceof\" class=\"headerlink\" title=\"9.instanceof\"></a>9.instanceof</h4><hr>\n<h3 id=\"作业5：把其他同学class2的作业阅读学习一遍\"><a href=\"#作业5：把其他同学class2的作业阅读学习一遍\" class=\"headerlink\" title=\"作业5：把其他同学class2的作业阅读学习一遍\"></a>作业5：把其他同学class2的作业阅读学习一遍</h3><h4 id=\"1-学习AJAX是什么，AJAX实现方法\"><a href=\"#1-学习AJAX是什么，AJAX实现方法\" class=\"headerlink\" title=\"1.学习AJAX是什么，AJAX实现方法\"></a>1.学习AJAX是什么，AJAX实现方法</h4><p><strong>1-1. 什么是AJAX？</strong></p>\n<ul>\n<li>Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</li>\n<li>Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。</li>\n<li>Ajax 是一种用于创建快速动态网页的技术。</li>\n<li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>\n</ul>\n<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<ul>\n<li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li>\n</ul>\n<p><strong>1-2. AJAX工作原理</strong></p>\n<p><img src=\"F:\\YoudaoNote\\weixinobU7VjqUHocAx3oC3CHYYNomdndU\\1a0ed37738cb43b893fc9187ff3d0429\\clipboard.png\" alt=\"img\"></p>\n<p><strong>1-3. AJAX是基于现有的Internet标准</strong></p>\n<ul>\n<li><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p>\n</li>\n<li><ul>\n<li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li>\n<li>JavaScript/DOM (信息显示/交互)</li>\n<li>CSS (给数据定义样式)</li>\n<li>XML (作为转换数据的格式)</li>\n</ul>\n</li>\n<li><p>AJAX应用程序与浏览器和平台无关的！</p>\n</li>\n<li><p>Ajax编程步骤：</p>\n<ul>\n<li>创建XMLHttpRequest对象。</li>\n<li>设置请求方式。</li>\n<li>调用回调函数。</li>\n<li>发送请求。</li>\n</ul>\n</li>\n</ul>\n<p><strong>1-4.原生JavaScript实现AJAX</strong></p>\n<p>XMLHttpRequest 是 AJAX 的基础。实现过程参考前面的XMLHttpRequest。</p>\n<p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;原生js实现ajax&lt;&#x2F;title&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        &#x2F;&#x2F;定义方法</span><br><span class=\"line\">        function fun() &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;发送异步请求</span><br><span class=\"line\">            &#x2F;&#x2F;1.创建核心对象</span><br><span class=\"line\">            var xmlhttp;</span><br><span class=\"line\">            if (window.XMLHttpRequest)&#123;&#x2F;&#x2F; code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class=\"line\">                xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class=\"line\">            &#125;else&#123;&#x2F;&#x2F; code for IE6, IE5</span><br><span class=\"line\">                xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;2.建立连接</span><br><span class=\"line\">            xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username&#x3D;tom&quot;,true);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;3.发送请求</span><br><span class=\"line\">            xmlhttp.send();</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;4.接收并处理服务器的响应结果</span><br><span class=\"line\">            &#x2F;&#x2F;获取方式：xmlhttp.responseText</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange</span><br><span class=\"line\">            xmlhttp.onreadystatechange&#x3D;function()&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;判断readyState是否为4，判断status响应状态码是否为200</span><br><span class=\"line\">                if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200)&#123;</span><br><span class=\"line\">                    var responseText &#x3D; xmlhttp.responseText;</span><br><span class=\"line\">                    alert(responseText);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;script&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;发送异步请求&quot; onclick&#x3D;&quot;fun()&quot;&gt;</span><br><span class=\"line\">    &lt;input&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\"><a href=\"#2-学习Javascript的模块化方式：AMD-CMD-CommonJS-ES-Module-UMD\" class=\"headerlink\" title=\"2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD\"></a>2.学习Javascript的模块化方式：AMD,CMD,CommonJS, ES Module, UMD</h4><p><strong>2-1 AMD</strong></p>\n"},{"_content":"## webstorm命令\n\n创建文件：type nul > test.html\n\n创建内容为“”的html文件：echo \"\" > index1.html\n\nhtml迅速框架命令：doc\n\nbody快捷方式:.container>p.test+span#next\n\n\n\n## 安装乌班图ubuntu和hyper：\n\nhttps://docs.microsoft.com/zh-cn/windows/wsl/install-win10\n\n启动子系统\n\n启动虚拟机功能\n\n下载linux内核更新包，重启电脑\n\n安装linux内核更新包，打开ubuntu\n\nhttps://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html\n\ninstall cURL and Git\n\ninstall Zsh\n\n输入：sudo vim /etc/hosts\n\n在结尾输入：199.232.68.133 raw.githubusercontent.com\n\n:wq  退出\n\ninstall oh my zsh\n\n### 下载nvm\n\n在git中搜索nvm\n\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.36.0/install.sh | bash\n```\n\n在zsh里面配置文件里导入\n\n```\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n\n\n## 打开webstorm:\n\n![image-20201018183438856](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183438856.png)\n\n\n\n打开.hyper.js,更改这两行代码，保存，打开hyper，连接乌班图![image-20201018183533862](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183533862.png)\n\n输入：bash -c zsh 使用zsh组件\n\n\n\n## 笔记：\n\n### 查看网站的ip地址：\n\n![img](file:///C:\\Users\\陈莉媛\\AppData\\Roaming\\Tencent\\TIM\\Temp\\%W@GJ$ACOF(TYDYECOKVDYB.png)http://ipaddress.com/\n\nsudo vim /etc/hosts  中添加\n\n\n\n###  修改webstorm的terminal：设置-terminal-修改shell地址：\n\n\"C:\\\\Windows\\\\System32\\\\cmd.exe\" --login --i /c wsl zsh\n\n\n\n![image-20201018192959634](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018192959634.png)\n\n\n\n## VPN配置\n\n#### 工具安装：\n\nVPN tool：https://github.com/Kr328/ClashForAndroid mac VPN tool: https://github.com/yichengchen/clashX windows VPN tool: https://github.com/Fndroid/clash_for_windows_pkg/releases\n\n#### Profiles Url\n\nhttps://feedneo.net/files/BSJsg8hV9o/clash.yml\n\nhttps://feedneo.net/files/r3CGJziTB9/clash.yml\n\n\n\n## http-server安装和启动\n\n​\t Http-server是一个基于nodejs的轻量级的http服务器，它最大好处就是：可以使任意一个本地目录开起成为一个本地服务器。比如，vue项目执行build构建，会生成一个dist目录，我们若想将项目部署到服务器，除了通过复制dist静态文件到服务器nginx目录下，然后启动nginx来启动项目，另外一个办法就是安装http-server 直接启动本地服务。\n\n### 下面则是http-server安装和启动：\n\n​\t参考：https://www.npmjs.com/package/http-server\n\n##### 全局安装：\n\n```\nnpm install --global http-server\n```\n\n##### 作为npm包依赖安装：\n\n```\nnpm install http-server\n```\n\n##### 运行\n\n终端进入你想要成为服务器的目录下，运行如下命令\n\n```\nhttp-server\n```\n\n若要禁用缓存，请使用如下命令运行\n\n```\nhttp-server -c-1\n```\n\n执行成功后，在浏览器输入http://localhost:8080/或者http://127.0.0.1:8080就可以访问你得文件了。\n\n##### 停止运行\n\nCtrl+C","source":"_posts/笔记.md","raw":"## webstorm命令\n\n创建文件：type nul > test.html\n\n创建内容为“”的html文件：echo \"\" > index1.html\n\nhtml迅速框架命令：doc\n\nbody快捷方式:.container>p.test+span#next\n\n\n\n## 安装乌班图ubuntu和hyper：\n\nhttps://docs.microsoft.com/zh-cn/windows/wsl/install-win10\n\n启动子系统\n\n启动虚拟机功能\n\n下载linux内核更新包，重启电脑\n\n安装linux内核更新包，打开ubuntu\n\nhttps://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html\n\ninstall cURL and Git\n\ninstall Zsh\n\n输入：sudo vim /etc/hosts\n\n在结尾输入：199.232.68.133 raw.githubusercontent.com\n\n:wq  退出\n\ninstall oh my zsh\n\n### 下载nvm\n\n在git中搜索nvm\n\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.36.0/install.sh | bash\n```\n\n在zsh里面配置文件里导入\n\n```\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n\n\n## 打开webstorm:\n\n![image-20201018183438856](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183438856.png)\n\n\n\n打开.hyper.js,更改这两行代码，保存，打开hyper，连接乌班图![image-20201018183533862](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183533862.png)\n\n输入：bash -c zsh 使用zsh组件\n\n\n\n## 笔记：\n\n### 查看网站的ip地址：\n\n![img](file:///C:\\Users\\陈莉媛\\AppData\\Roaming\\Tencent\\TIM\\Temp\\%W@GJ$ACOF(TYDYECOKVDYB.png)http://ipaddress.com/\n\nsudo vim /etc/hosts  中添加\n\n\n\n###  修改webstorm的terminal：设置-terminal-修改shell地址：\n\n\"C:\\\\Windows\\\\System32\\\\cmd.exe\" --login --i /c wsl zsh\n\n\n\n![image-20201018192959634](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018192959634.png)\n\n\n\n## VPN配置\n\n#### 工具安装：\n\nVPN tool：https://github.com/Kr328/ClashForAndroid mac VPN tool: https://github.com/yichengchen/clashX windows VPN tool: https://github.com/Fndroid/clash_for_windows_pkg/releases\n\n#### Profiles Url\n\nhttps://feedneo.net/files/BSJsg8hV9o/clash.yml\n\nhttps://feedneo.net/files/r3CGJziTB9/clash.yml\n\n\n\n## http-server安装和启动\n\n​\t Http-server是一个基于nodejs的轻量级的http服务器，它最大好处就是：可以使任意一个本地目录开起成为一个本地服务器。比如，vue项目执行build构建，会生成一个dist目录，我们若想将项目部署到服务器，除了通过复制dist静态文件到服务器nginx目录下，然后启动nginx来启动项目，另外一个办法就是安装http-server 直接启动本地服务。\n\n### 下面则是http-server安装和启动：\n\n​\t参考：https://www.npmjs.com/package/http-server\n\n##### 全局安装：\n\n```\nnpm install --global http-server\n```\n\n##### 作为npm包依赖安装：\n\n```\nnpm install http-server\n```\n\n##### 运行\n\n终端进入你想要成为服务器的目录下，运行如下命令\n\n```\nhttp-server\n```\n\n若要禁用缓存，请使用如下命令运行\n\n```\nhttp-server -c-1\n```\n\n执行成功后，在浏览器输入http://localhost:8080/或者http://127.0.0.1:8080就可以访问你得文件了。\n\n##### 停止运行\n\nCtrl+C","slug":"笔记","published":1,"date":"2020-11-01T00:47:05.531Z","updated":"2020-10-25T06:08:08.808Z","_id":"ckgye9w7a0002q0tzdvta8fpa","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"webstorm命令\"><a href=\"#webstorm命令\" class=\"headerlink\" title=\"webstorm命令\"></a>webstorm命令</h2><p>创建文件：type nul &gt; test.html</p>\n<p>创建内容为“”的html文件：echo “” &gt; index1.html</p>\n<p>html迅速框架命令：doc</p>\n<p>body快捷方式:.container&gt;p.test+span#next</p>\n<h2 id=\"安装乌班图ubuntu和hyper：\"><a href=\"#安装乌班图ubuntu和hyper：\" class=\"headerlink\" title=\"安装乌班图ubuntu和hyper：\"></a>安装乌班图ubuntu和hyper：</h2><p><a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-win10\">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></p>\n<p>启动子系统</p>\n<p>启动虚拟机功能</p>\n<p>下载linux内核更新包，重启电脑</p>\n<p>安装linux内核更新包，打开ubuntu</p>\n<p><a href=\"https://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html\">https://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html</a></p>\n<p>install cURL and Git</p>\n<p>install Zsh</p>\n<p>输入：sudo vim /etc/hosts</p>\n<p>在结尾输入：199.232.68.133 raw.githubusercontent.com</p>\n<p>:wq  退出</p>\n<p>install oh my zsh</p>\n<h3 id=\"下载nvm\"><a href=\"#下载nvm\" class=\"headerlink\" title=\"下载nvm\"></a>下载nvm</h3><p>在git中搜索nvm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.36.0&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>\n\n<p>在zsh里面配置文件里导入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NVM_DIR&#x3D;&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;&#x2F;.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;&#x2F;nvm&quot;)&quot;</span><br><span class=\"line\">[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"打开webstorm\"><a href=\"#打开webstorm\" class=\"headerlink\" title=\"打开webstorm:\"></a>打开webstorm:</h2><p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183438856.png\" alt=\"image-20201018183438856\"></p>\n<p>打开.hyper.js,更改这两行代码，保存，打开hyper，连接乌班图<img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183533862.png\" alt=\"image-20201018183533862\"></p>\n<p>输入：bash -c zsh 使用zsh组件</p>\n<h2 id=\"笔记：\"><a href=\"#笔记：\" class=\"headerlink\" title=\"笔记：\"></a>笔记：</h2><h3 id=\"查看网站的ip地址：\"><a href=\"#查看网站的ip地址：\" class=\"headerlink\" title=\"查看网站的ip地址：\"></a>查看网站的ip地址：</h3><p><img src=\"file:///C:\\Users\\陈莉媛\\AppData\\Roaming\\Tencent\\TIM\\Temp%W@GJ$ACOF(TYDYECOKVDYB.png\" alt=\"img\"><a href=\"http://ipaddress.com/\">http://ipaddress.com/</a></p>\n<p>sudo vim /etc/hosts  中添加</p>\n<h3 id=\"修改webstorm的terminal：设置-terminal-修改shell地址：\"><a href=\"#修改webstorm的terminal：设置-terminal-修改shell地址：\" class=\"headerlink\" title=\"修改webstorm的terminal：设置-terminal-修改shell地址：\"></a>修改webstorm的terminal：设置-terminal-修改shell地址：</h3><p>“C:\\Windows\\System32\\cmd.exe” –login –i /c wsl zsh</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018192959634.png\" alt=\"image-20201018192959634\"></p>\n<h2 id=\"VPN配置\"><a href=\"#VPN配置\" class=\"headerlink\" title=\"VPN配置\"></a>VPN配置</h2><h4 id=\"工具安装：\"><a href=\"#工具安装：\" class=\"headerlink\" title=\"工具安装：\"></a>工具安装：</h4><p>VPN tool：<a href=\"https://github.com/Kr328/ClashForAndroid\">https://github.com/Kr328/ClashForAndroid</a> mac VPN tool: <a href=\"https://github.com/yichengchen/clashX\">https://github.com/yichengchen/clashX</a> windows VPN tool: <a href=\"https://github.com/Fndroid/clash_for_windows_pkg/releases\">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></p>\n<h4 id=\"Profiles-Url\"><a href=\"#Profiles-Url\" class=\"headerlink\" title=\"Profiles Url\"></a>Profiles Url</h4><p><a href=\"https://feedneo.net/files/BSJsg8hV9o/clash.yml\">https://feedneo.net/files/BSJsg8hV9o/clash.yml</a></p>\n<p><a href=\"https://feedneo.net/files/r3CGJziTB9/clash.yml\">https://feedneo.net/files/r3CGJziTB9/clash.yml</a></p>\n<h2 id=\"http-server安装和启动\"><a href=\"#http-server安装和启动\" class=\"headerlink\" title=\"http-server安装和启动\"></a>http-server安装和启动</h2><p>​     Http-server是一个基于nodejs的轻量级的http服务器，它最大好处就是：可以使任意一个本地目录开起成为一个本地服务器。比如，vue项目执行build构建，会生成一个dist目录，我们若想将项目部署到服务器，除了通过复制dist静态文件到服务器nginx目录下，然后启动nginx来启动项目，另外一个办法就是安装http-server 直接启动本地服务。</p>\n<h3 id=\"下面则是http-server安装和启动：\"><a href=\"#下面则是http-server安装和启动：\" class=\"headerlink\" title=\"下面则是http-server安装和启动：\"></a>下面则是http-server安装和启动：</h3><p>​    参考：<a href=\"https://www.npmjs.com/package/http-server\">https://www.npmjs.com/package/http-server</a></p>\n<h5 id=\"全局安装：\"><a href=\"#全局安装：\" class=\"headerlink\" title=\"全局安装：\"></a>全局安装：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global http-server</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"作为npm包依赖安装：\"><a href=\"#作为npm包依赖安装：\" class=\"headerlink\" title=\"作为npm包依赖安装：\"></a>作为npm包依赖安装：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install http-server</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h5><p>终端进入你想要成为服务器的目录下，运行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n\n<p>若要禁用缓存，请使用如下命令运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server -c-1</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，在浏览器输入<a href=\"http://localhost:8080/%E6%88%96%E8%80%85http://127.0.0.1:8080%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E4%BD%A0%E5%BE%97%E6%96%87%E4%BB%B6%E4%BA%86%E3%80%82\">http://localhost:8080/或者http://127.0.0.1:8080就可以访问你得文件了。</a></p>\n<h5 id=\"停止运行\"><a href=\"#停止运行\" class=\"headerlink\" title=\"停止运行\"></a>停止运行</h5><p>Ctrl+C</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"webstorm命令\"><a href=\"#webstorm命令\" class=\"headerlink\" title=\"webstorm命令\"></a>webstorm命令</h2><p>创建文件：type nul &gt; test.html</p>\n<p>创建内容为“”的html文件：echo “” &gt; index1.html</p>\n<p>html迅速框架命令：doc</p>\n<p>body快捷方式:.container&gt;p.test+span#next</p>\n<h2 id=\"安装乌班图ubuntu和hyper：\"><a href=\"#安装乌班图ubuntu和hyper：\" class=\"headerlink\" title=\"安装乌班图ubuntu和hyper：\"></a>安装乌班图ubuntu和hyper：</h2><p><a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-win10\">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></p>\n<p>启动子系统</p>\n<p>启动虚拟机功能</p>\n<p>下载linux内核更新包，重启电脑</p>\n<p>安装linux内核更新包，打开ubuntu</p>\n<p><a href=\"https://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html\">https://evdokimovm.github.io/windows/zsh/shell/syntax/highlighting/ohmyzsh/hyper/terminal/2017/02/24/how-to-install-zsh-and-oh-my-zsh-on-windows-10.html</a></p>\n<p>install cURL and Git</p>\n<p>install Zsh</p>\n<p>输入：sudo vim /etc/hosts</p>\n<p>在结尾输入：199.232.68.133 raw.githubusercontent.com</p>\n<p>:wq  退出</p>\n<p>install oh my zsh</p>\n<h3 id=\"下载nvm\"><a href=\"#下载nvm\" class=\"headerlink\" title=\"下载nvm\"></a>下载nvm</h3><p>在git中搜索nvm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.36.0&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>\n\n<p>在zsh里面配置文件里导入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NVM_DIR&#x3D;&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;&#x2F;.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;&#x2F;nvm&quot;)&quot;</span><br><span class=\"line\">[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"打开webstorm\"><a href=\"#打开webstorm\" class=\"headerlink\" title=\"打开webstorm:\"></a>打开webstorm:</h2><p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183438856.png\" alt=\"image-20201018183438856\"></p>\n<p>打开.hyper.js,更改这两行代码，保存，打开hyper，连接乌班图<img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018183533862.png\" alt=\"image-20201018183533862\"></p>\n<p>输入：bash -c zsh 使用zsh组件</p>\n<h2 id=\"笔记：\"><a href=\"#笔记：\" class=\"headerlink\" title=\"笔记：\"></a>笔记：</h2><h3 id=\"查看网站的ip地址：\"><a href=\"#查看网站的ip地址：\" class=\"headerlink\" title=\"查看网站的ip地址：\"></a>查看网站的ip地址：</h3><p><img src=\"file:///C:\\Users\\陈莉媛\\AppData\\Roaming\\Tencent\\TIM\\Temp%W@GJ$ACOF(TYDYECOKVDYB.png\" alt=\"img\"><a href=\"http://ipaddress.com/\">http://ipaddress.com/</a></p>\n<p>sudo vim /etc/hosts  中添加</p>\n<h3 id=\"修改webstorm的terminal：设置-terminal-修改shell地址：\"><a href=\"#修改webstorm的terminal：设置-terminal-修改shell地址：\" class=\"headerlink\" title=\"修改webstorm的terminal：设置-terminal-修改shell地址：\"></a>修改webstorm的terminal：设置-terminal-修改shell地址：</h3><p>“C:\\Windows\\System32\\cmd.exe” –login –i /c wsl zsh</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201018192959634.png\" alt=\"image-20201018192959634\"></p>\n<h2 id=\"VPN配置\"><a href=\"#VPN配置\" class=\"headerlink\" title=\"VPN配置\"></a>VPN配置</h2><h4 id=\"工具安装：\"><a href=\"#工具安装：\" class=\"headerlink\" title=\"工具安装：\"></a>工具安装：</h4><p>VPN tool：<a href=\"https://github.com/Kr328/ClashForAndroid\">https://github.com/Kr328/ClashForAndroid</a> mac VPN tool: <a href=\"https://github.com/yichengchen/clashX\">https://github.com/yichengchen/clashX</a> windows VPN tool: <a href=\"https://github.com/Fndroid/clash_for_windows_pkg/releases\">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></p>\n<h4 id=\"Profiles-Url\"><a href=\"#Profiles-Url\" class=\"headerlink\" title=\"Profiles Url\"></a>Profiles Url</h4><p><a href=\"https://feedneo.net/files/BSJsg8hV9o/clash.yml\">https://feedneo.net/files/BSJsg8hV9o/clash.yml</a></p>\n<p><a href=\"https://feedneo.net/files/r3CGJziTB9/clash.yml\">https://feedneo.net/files/r3CGJziTB9/clash.yml</a></p>\n<h2 id=\"http-server安装和启动\"><a href=\"#http-server安装和启动\" class=\"headerlink\" title=\"http-server安装和启动\"></a>http-server安装和启动</h2><p>​     Http-server是一个基于nodejs的轻量级的http服务器，它最大好处就是：可以使任意一个本地目录开起成为一个本地服务器。比如，vue项目执行build构建，会生成一个dist目录，我们若想将项目部署到服务器，除了通过复制dist静态文件到服务器nginx目录下，然后启动nginx来启动项目，另外一个办法就是安装http-server 直接启动本地服务。</p>\n<h3 id=\"下面则是http-server安装和启动：\"><a href=\"#下面则是http-server安装和启动：\" class=\"headerlink\" title=\"下面则是http-server安装和启动：\"></a>下面则是http-server安装和启动：</h3><p>​    参考：<a href=\"https://www.npmjs.com/package/http-server\">https://www.npmjs.com/package/http-server</a></p>\n<h5 id=\"全局安装：\"><a href=\"#全局安装：\" class=\"headerlink\" title=\"全局安装：\"></a>全局安装：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global http-server</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"作为npm包依赖安装：\"><a href=\"#作为npm包依赖安装：\" class=\"headerlink\" title=\"作为npm包依赖安装：\"></a>作为npm包依赖安装：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install http-server</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h5><p>终端进入你想要成为服务器的目录下，运行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server</span><br></pre></td></tr></table></figure>\n\n<p>若要禁用缓存，请使用如下命令运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http-server -c-1</span><br></pre></td></tr></table></figure>\n\n<p>执行成功后，在浏览器输入<a href=\"http://localhost:8080/%E6%88%96%E8%80%85http://127.0.0.1:8080%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E4%BD%A0%E5%BE%97%E6%96%87%E4%BB%B6%E4%BA%86%E3%80%82\">http://localhost:8080/或者http://127.0.0.1:8080就可以访问你得文件了。</a></p>\n<h5 id=\"停止运行\"><a href=\"#停止运行\" class=\"headerlink\" title=\"停止运行\"></a>停止运行</h5><p>Ctrl+C</p>\n"},{"_content":"## 作业1: 学习/复习markdown语法\n\n已看。\n\n---\n\n\n\n## 作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\n\n> 2-1、了解linux的基本命令\n\n- **ls**\n   - ls：列出当前目录下的所有目录\n   - ls -F ：查看目录中的文件 \n   - ls -l ：显示文件和目录的详细资料 \n   - ls -a：显示隐藏文件 \n   - ls *[0-9]* ：显示包含数字的文件名和目录名 \n\n- **cd**\n\n   - cd ~ ： 子系统根目录\n   - cd ：进入个人的主目录\n   - cd ..  ：返回上级目录\n   - cd -  ：返回上次所在目录\n   - cd ../.. ：返回上两级目录\n   - cd /home ：进入‘/home'目录\n\n-  **tree** ：显示文件和目录由根目录开始的树形结构\n\n- **mkdir**：创建一个子目录\n\n- **rm**\n\n   - rm -f file1 删除一个叫做 'file1' 的文件' \n   - rmdir dir1 删除一个叫做 'dir1' 的目录' \n   - rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 \n   - rm -rf dir1 dir2 同时删除两个目录及它们的内容\n\n- **l**: 查看文件大小\n\n- **vi**: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。\n\n  ​\t使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：\n\n  1. 命令模式\n\n     ​\t控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。\n\n     - ①光标移动\n\n       ![image-20201021100752987](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png)\n\n     - ②删除文本\n\n       ![image-20201021100853637](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png)\n\n     - ③删除、复制、粘贴、查找、替换、撤销\n\n       ![image-20201021101000073](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png)\n\n       \n\n  2. 插入模式\n\n     ​\t只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。\n\n     ![image-20201021101108024](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png)\n\n     \n\n  3. 底行模式\n\n     ​\t将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。\n\n  ![image-20201021101215216](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png)\n\n  ​\t注意：在底行模式下的命令，需要按回车键才执行该命令。\n\n  \n\n  4. 切换模式\n\n     ![image-20201021101328117](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png)\n\n     实现以上过程的命令：\n\n     　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；\n\n     　　过程②：按a、i、o或s键，实现命令模式——>插入模式；\n\n     　　过程③：按Esc键，实现插入模式——>命令模式；\n\n     　　过程④：输入：或 /，实现命令模式——>底行模式；\n\n     　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——>命令模式；\n\n     　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。\n\n- **curl**：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。\n\n  语法：`# curl [option] [url]`\n\n  1. 保存访问的网页\n     - 使用linux的重定向功能保存 ` curl http://www.linux.com>>linux.html`\n     - 使用curl的内置option:-o(小写)保存网页 ` curl -o linux.html http://www.linux.com`\n     - 使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）`curl -O http://www.linux.com/hello.sh`\n     \n  2. 测试网页返回值 `curl -o /dev/null -s -w %{http_code} www.linux.com`\n\n     *Ps:在脚本中，这是很常见的测试网站是否正常的用法*\n\n  3. 指定proxy服务器以及其端口\n\n     很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理\n\n     `curl -x 192.168.100.100:1080 http://www.linux.com`\n\n  4. cookie\n\n     - 保存http的response里面的cookie信息。内置option:-c（小写）\n\n       `curl -c cookiec.txt  http://www.linux.com` 保存到cookiec.txt中\n\n     - 保存http的response里面的header信息。内置option: -D\n\n       `curl -D cookied.txt http://www.linux.com`\n\n     - 使用cookie\n\n       很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b\n\n       `curl -b cookiec.txt http://www.linux.com`\n\n  5. 模仿浏览器\n\n     有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站\n\n     `curl -A \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)\" http://www.linux.com`\n\n     这样服务器端就会认为是使用IE8.0去访问的\n\n  6. 伪造referer（盗链）\n\n     很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了\n     curl中内置option：-e可以让我们设定referer\n\n     `curl -e \"www.linux.com\" http://mail.linux.com`\n\n     这样就会让服务器其以为你是从www.linux.com点击某个链接过来的\n\n  7. 下载文件\n\n     - 利用curl下载文件 option：-o(小写大写)\n\n     - 循环下载\n\n       有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5\n\n       ```\n       curl -O http://www.linux.com/dodo[1-5].JPG\n       ```\n\n     - 下载重命名\n\n       `curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG`\n\n       这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖\n\n     - 分块下载\n\n       有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r\n\n       ```\n       # curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG\n       # cat dodo1_part* > dodo1.JPG\n       ```\n\n     - 通过ftp下载文件\n\n       curl提供两种从ftp中下载的语法\n\n       ```\n       curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG\n       curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG\n       ```\n\n     - 显示下载进度条 `curl -# -O http://www.linux.com/dodo1.JPG`\n\n     - 不会显示下载进度信息 `curl -s -O http://www.linux.com/dodo1.JPG`\n\n  8. 断点续传\n\n     在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果\n     如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传\n\n     `curl -C -O http://www.linux.com/dodo1.JPG`\n\n  9. 上传文件\n\n     curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现\n\n     ```\n     curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/\n     ```\n\n     这样就向ftp服务器上传了文件dodo1.JPG\n\n  10. 显示抓取错误 `curl -f http://www.linux.com/error`\n\n- **wget**: wget命令用来从指定的URL下载文件。\n\n   ​\twget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。\n\n   语法：`wget (选项) (url地址)`\n\n   选项：\n\n   | 选项         | 描述                                                      |\n   | ------------ | --------------------------------------------------------- |\n   | -a<日志文件> | 在指定的日志文件中记录资料的执行过程；                    |\n   | -A<后缀名>   | 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；  |\n   | -b           | 进行后台的方式运行wget；                                  |\n   | -B<连接地址> | 设置参考的连接地址的基地地址；                            |\n   | -c           | 继续执行上次终端的任务；                                  |\n   | -C<标志>     | 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； |\n   | -d           | 调试模式运行指令；                                        |\n   | -D<域名列表> | 设置顺着的域名列表，域名之间用“，”分隔；                  |\n   | -e<指令>     | 作为文件“.wgetrc”中的一部分执行指定的指令；               |\n   | -h           | 显示指令帮助信息；                                        |\n   | -i<文件>     | 从指定文件获取要下载的URL地址；                           |\n   | -l<目录列表> | 设置顺着的目录列表，多个目录用“，”分隔；                  |\n   | -L           | 仅顺着关联的连接；                                        |\n   | -r           | 递归下载方式；                                            |\n   | -nc          | 文件存在时，下载文件不覆盖原有文件；                      |\n   | -nv          | 下载时只显示更新和出错信息，不显示指令的详细执行过程；    |\n   | -q           | 不显示指令执行过程；                                      |\n   | -nh          | 不查询主机名称；                                          |\n   | -v           | 显示详细执行过程；                                        |\n   | -V           | 显示版本信息；                                            |\n   | –passive-ftp | 使用被动模式PASV连接FTP服务器；                           |\n   | –follow-ftp  | 从HTML文件中下载FTP连接文件。                             |\n\n   - `wget http://test.com/testfile.zip `->下载指定文件到当前文件夹\n   - `wget -O wordpress.zip http://test.com/download `->指定保存名字\n   - `wget --limit-rate=300k http://www.linuxde.net/testfile.zip `->限制下载速度\n   - `wget -c http://www.linuxde.net/testfile.zip `->断点续传\n   - `wget -b http://www.linuxde.net/testfile.zip` ->后台下载\n\n   > *设置使用指定浏览器下载（伪装下载）*\n\n   - `wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.linuxde.net/testfile.zip`\n\n   - `wget --spider url` ->测试下载\n   - `wget --tries=40 URL` ->设置重试次数为40\n   - `wget -i filelist.txt ->从filelist.txt `  获取下载地址\n\n   > *镜像网站*\n   >\n   > *`--mirror`开户镜像下载。*\n   >\n   > *`-p`下载所有为了`html`页面显示正常的文件。*\n   >\n   > *`--convert-links`下载后，转换成本地的链接。*\n   >\n   > *`-P ./LOCAL`保存所有文件和目录到本地指定目录*\n\n   - `wget --mirror -p --convert-links -P ./LOCAL URL`\n\n   - `wget --reject=gif url` ->下载一个网站，但你不希望下载图片，可以使用这条命令\n   - `wget -o download.log URL `->把下载信息存入日志文件\n   - `wget -Q5m -i filelist.txt` ->限制总下载文件大小\n   - `wget -r -A.pdf url `->下载指定格式文件\n\n   > *FTP下载*\n\n   - `wget ftp-url`\n   - `wget --ftp-user=USERNAME --ftp-password=PASSWORD url`\n\n- **apt-get**: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。\n\n   apt-get命令一般需要root权限执行，所以一般跟着`sudo`命令。\n\n   - **更新、下载**\n\n     > **apt-get update**  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。\n     >\n     > **sudo apt-get install packagename**  :安装一个新软件包\n     >\n     > **upgrate**：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。\n\n   - **删除已安装的包**\n\n     > **apt-get remove packagename**   :  卸载一个已安装的软件包（保留配置文档）\n     >\n     > **apt-get remove --purge packagename**   :卸载一个已安装的软件包（删除配置文档）\n     >\n     > **apt-get autoremove packagename**  :  删除包及其依赖的软件包\n     >\n     > **apt-get autoremove --purge packagname**    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点\n\n   - **清理系统**\n\n     > **apt-get autoclean**   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。\n     >\n     > **apt-get clean**  :  清除检索到的包文件的本地存储库.\n\n   - **apt-cache**\n\n     > search：搜索包\n     >\n     > pkgnames：搜索具有特定名称的包\n     >\n     > showpkg：查看包的详细信息\n\n     \n\n> 2-2、了解学习oh-my-zsh\n\n​\tOh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。\n\n---\n\n\n\n## 作业三：yum是什么\n\n​\t\tYum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的**Shell前端软件包管理器**。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\n​\t\tyum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。\n\n​\t\tyum的常用命令：\n\n| yum check-update              | 列出所有可更新的软件清单                                   |\n| ----------------------------- | ---------------------------------------------------------- |\n| yum update                    | 安装所有更新软件                                           |\n| yum -y install <package_name> | 安装指定的软件                                             |\n| yum update <package_name>     | 更新指定的软件                                             |\n| yum list  <package_name>      | 不加<package_name>列出所有可安裝的软件清单，加了列出指定的 |\n| yum -y remove <package_name>  | 删除软件                                                   |\n| yum search <package_name>     | 查找软件                                                   |\n| yum list installed            | 列出所有已安装的软件包                                     |\n| yum list extras               | 列出所有已安装但不在Yum Repository 內的软件包              |\n| yum clean all                 | 清除缓存目录(/var/cache/yum)下的软件包及旧的headers        |\n| yum info <package_name>       | 不加<package_name>列出所有软件包的信息，加了列出指定的     |\n| yum provides <package_name>   | 列出软件包提供哪些文件                                     |\n| yum clean packages            | 清除缓存目录(/var/cache/yum)下的软件包                     |\n| yum deplist <package_name>    | 显示软件包依赖关系                                         |\n| -y                            | 自动应答yes                                                |\n| -t                            | 忽略错误                                                   |\n| -q                            | 静默执行                                                   |\n| --skip-broken                 | 忽略依赖问题                                               |\n| --nogpgcheck                  | 忽略GPG验证                                                |\n| -R[分钟]                      | 设置等待时间                                               |\n\n","source":"_posts/作业一.md","raw":"## 作业1: 学习/复习markdown语法\n\n已看。\n\n---\n\n\n\n## 作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\n\n> 2-1、了解linux的基本命令\n\n- **ls**\n   - ls：列出当前目录下的所有目录\n   - ls -F ：查看目录中的文件 \n   - ls -l ：显示文件和目录的详细资料 \n   - ls -a：显示隐藏文件 \n   - ls *[0-9]* ：显示包含数字的文件名和目录名 \n\n- **cd**\n\n   - cd ~ ： 子系统根目录\n   - cd ：进入个人的主目录\n   - cd ..  ：返回上级目录\n   - cd -  ：返回上次所在目录\n   - cd ../.. ：返回上两级目录\n   - cd /home ：进入‘/home'目录\n\n-  **tree** ：显示文件和目录由根目录开始的树形结构\n\n- **mkdir**：创建一个子目录\n\n- **rm**\n\n   - rm -f file1 删除一个叫做 'file1' 的文件' \n   - rmdir dir1 删除一个叫做 'dir1' 的目录' \n   - rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 \n   - rm -rf dir1 dir2 同时删除两个目录及它们的内容\n\n- **l**: 查看文件大小\n\n- **vi**: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。\n\n  ​\t使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：\n\n  1. 命令模式\n\n     ​\t控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。\n\n     - ①光标移动\n\n       ![image-20201021100752987](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png)\n\n     - ②删除文本\n\n       ![image-20201021100853637](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png)\n\n     - ③删除、复制、粘贴、查找、替换、撤销\n\n       ![image-20201021101000073](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png)\n\n       \n\n  2. 插入模式\n\n     ​\t只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。\n\n     ![image-20201021101108024](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png)\n\n     \n\n  3. 底行模式\n\n     ​\t将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。\n\n  ![image-20201021101215216](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png)\n\n  ​\t注意：在底行模式下的命令，需要按回车键才执行该命令。\n\n  \n\n  4. 切换模式\n\n     ![image-20201021101328117](C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png)\n\n     实现以上过程的命令：\n\n     　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；\n\n     　　过程②：按a、i、o或s键，实现命令模式——>插入模式；\n\n     　　过程③：按Esc键，实现插入模式——>命令模式；\n\n     　　过程④：输入：或 /，实现命令模式——>底行模式；\n\n     　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——>命令模式；\n\n     　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。\n\n- **curl**：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。\n\n  语法：`# curl [option] [url]`\n\n  1. 保存访问的网页\n     - 使用linux的重定向功能保存 ` curl http://www.linux.com>>linux.html`\n     - 使用curl的内置option:-o(小写)保存网页 ` curl -o linux.html http://www.linux.com`\n     - 使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）`curl -O http://www.linux.com/hello.sh`\n     \n  2. 测试网页返回值 `curl -o /dev/null -s -w %{http_code} www.linux.com`\n\n     *Ps:在脚本中，这是很常见的测试网站是否正常的用法*\n\n  3. 指定proxy服务器以及其端口\n\n     很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理\n\n     `curl -x 192.168.100.100:1080 http://www.linux.com`\n\n  4. cookie\n\n     - 保存http的response里面的cookie信息。内置option:-c（小写）\n\n       `curl -c cookiec.txt  http://www.linux.com` 保存到cookiec.txt中\n\n     - 保存http的response里面的header信息。内置option: -D\n\n       `curl -D cookied.txt http://www.linux.com`\n\n     - 使用cookie\n\n       很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b\n\n       `curl -b cookiec.txt http://www.linux.com`\n\n  5. 模仿浏览器\n\n     有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站\n\n     `curl -A \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)\" http://www.linux.com`\n\n     这样服务器端就会认为是使用IE8.0去访问的\n\n  6. 伪造referer（盗链）\n\n     很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了\n     curl中内置option：-e可以让我们设定referer\n\n     `curl -e \"www.linux.com\" http://mail.linux.com`\n\n     这样就会让服务器其以为你是从www.linux.com点击某个链接过来的\n\n  7. 下载文件\n\n     - 利用curl下载文件 option：-o(小写大写)\n\n     - 循环下载\n\n       有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5\n\n       ```\n       curl -O http://www.linux.com/dodo[1-5].JPG\n       ```\n\n     - 下载重命名\n\n       `curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG`\n\n       这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖\n\n     - 分块下载\n\n       有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r\n\n       ```\n       # curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG\n       # curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG\n       # cat dodo1_part* > dodo1.JPG\n       ```\n\n     - 通过ftp下载文件\n\n       curl提供两种从ftp中下载的语法\n\n       ```\n       curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG\n       curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG\n       ```\n\n     - 显示下载进度条 `curl -# -O http://www.linux.com/dodo1.JPG`\n\n     - 不会显示下载进度信息 `curl -s -O http://www.linux.com/dodo1.JPG`\n\n  8. 断点续传\n\n     在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果\n     如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传\n\n     `curl -C -O http://www.linux.com/dodo1.JPG`\n\n  9. 上传文件\n\n     curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现\n\n     ```\n     curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/\n     ```\n\n     这样就向ftp服务器上传了文件dodo1.JPG\n\n  10. 显示抓取错误 `curl -f http://www.linux.com/error`\n\n- **wget**: wget命令用来从指定的URL下载文件。\n\n   ​\twget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。\n\n   语法：`wget (选项) (url地址)`\n\n   选项：\n\n   | 选项         | 描述                                                      |\n   | ------------ | --------------------------------------------------------- |\n   | -a<日志文件> | 在指定的日志文件中记录资料的执行过程；                    |\n   | -A<后缀名>   | 指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；  |\n   | -b           | 进行后台的方式运行wget；                                  |\n   | -B<连接地址> | 设置参考的连接地址的基地地址；                            |\n   | -c           | 继续执行上次终端的任务；                                  |\n   | -C<标志>     | 设置服务器数据块功能标志on为激活，off为关闭，默认值为on； |\n   | -d           | 调试模式运行指令；                                        |\n   | -D<域名列表> | 设置顺着的域名列表，域名之间用“，”分隔；                  |\n   | -e<指令>     | 作为文件“.wgetrc”中的一部分执行指定的指令；               |\n   | -h           | 显示指令帮助信息；                                        |\n   | -i<文件>     | 从指定文件获取要下载的URL地址；                           |\n   | -l<目录列表> | 设置顺着的目录列表，多个目录用“，”分隔；                  |\n   | -L           | 仅顺着关联的连接；                                        |\n   | -r           | 递归下载方式；                                            |\n   | -nc          | 文件存在时，下载文件不覆盖原有文件；                      |\n   | -nv          | 下载时只显示更新和出错信息，不显示指令的详细执行过程；    |\n   | -q           | 不显示指令执行过程；                                      |\n   | -nh          | 不查询主机名称；                                          |\n   | -v           | 显示详细执行过程；                                        |\n   | -V           | 显示版本信息；                                            |\n   | –passive-ftp | 使用被动模式PASV连接FTP服务器；                           |\n   | –follow-ftp  | 从HTML文件中下载FTP连接文件。                             |\n\n   - `wget http://test.com/testfile.zip `->下载指定文件到当前文件夹\n   - `wget -O wordpress.zip http://test.com/download `->指定保存名字\n   - `wget --limit-rate=300k http://www.linuxde.net/testfile.zip `->限制下载速度\n   - `wget -c http://www.linuxde.net/testfile.zip `->断点续传\n   - `wget -b http://www.linuxde.net/testfile.zip` ->后台下载\n\n   > *设置使用指定浏览器下载（伪装下载）*\n\n   - `wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.linuxde.net/testfile.zip`\n\n   - `wget --spider url` ->测试下载\n   - `wget --tries=40 URL` ->设置重试次数为40\n   - `wget -i filelist.txt ->从filelist.txt `  获取下载地址\n\n   > *镜像网站*\n   >\n   > *`--mirror`开户镜像下载。*\n   >\n   > *`-p`下载所有为了`html`页面显示正常的文件。*\n   >\n   > *`--convert-links`下载后，转换成本地的链接。*\n   >\n   > *`-P ./LOCAL`保存所有文件和目录到本地指定目录*\n\n   - `wget --mirror -p --convert-links -P ./LOCAL URL`\n\n   - `wget --reject=gif url` ->下载一个网站，但你不希望下载图片，可以使用这条命令\n   - `wget -o download.log URL `->把下载信息存入日志文件\n   - `wget -Q5m -i filelist.txt` ->限制总下载文件大小\n   - `wget -r -A.pdf url `->下载指定格式文件\n\n   > *FTP下载*\n\n   - `wget ftp-url`\n   - `wget --ftp-user=USERNAME --ftp-password=PASSWORD url`\n\n- **apt-get**: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。\n\n   apt-get命令一般需要root权限执行，所以一般跟着`sudo`命令。\n\n   - **更新、下载**\n\n     > **apt-get update**  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。\n     >\n     > **sudo apt-get install packagename**  :安装一个新软件包\n     >\n     > **upgrate**：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。\n\n   - **删除已安装的包**\n\n     > **apt-get remove packagename**   :  卸载一个已安装的软件包（保留配置文档）\n     >\n     > **apt-get remove --purge packagename**   :卸载一个已安装的软件包（删除配置文档）\n     >\n     > **apt-get autoremove packagename**  :  删除包及其依赖的软件包\n     >\n     > **apt-get autoremove --purge packagname**    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点\n\n   - **清理系统**\n\n     > **apt-get autoclean**   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。\n     >\n     > **apt-get clean**  :  清除检索到的包文件的本地存储库.\n\n   - **apt-cache**\n\n     > search：搜索包\n     >\n     > pkgnames：搜索具有特定名称的包\n     >\n     > showpkg：查看包的详细信息\n\n     \n\n> 2-2、了解学习oh-my-zsh\n\n​\tOh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。\n\n---\n\n\n\n## 作业三：yum是什么\n\n​\t\tYum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的**Shell前端软件包管理器**。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\n​\t\tyum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。\n\n​\t\tyum的常用命令：\n\n| yum check-update              | 列出所有可更新的软件清单                                   |\n| ----------------------------- | ---------------------------------------------------------- |\n| yum update                    | 安装所有更新软件                                           |\n| yum -y install <package_name> | 安装指定的软件                                             |\n| yum update <package_name>     | 更新指定的软件                                             |\n| yum list  <package_name>      | 不加<package_name>列出所有可安裝的软件清单，加了列出指定的 |\n| yum -y remove <package_name>  | 删除软件                                                   |\n| yum search <package_name>     | 查找软件                                                   |\n| yum list installed            | 列出所有已安装的软件包                                     |\n| yum list extras               | 列出所有已安装但不在Yum Repository 內的软件包              |\n| yum clean all                 | 清除缓存目录(/var/cache/yum)下的软件包及旧的headers        |\n| yum info <package_name>       | 不加<package_name>列出所有软件包的信息，加了列出指定的     |\n| yum provides <package_name>   | 列出软件包提供哪些文件                                     |\n| yum clean packages            | 清除缓存目录(/var/cache/yum)下的软件包                     |\n| yum deplist <package_name>    | 显示软件包依赖关系                                         |\n| -y                            | 自动应答yes                                                |\n| -t                            | 忽略错误                                                   |\n| -q                            | 静默执行                                                   |\n| --skip-broken                 | 忽略依赖问题                                               |\n| --nogpgcheck                  | 忽略GPG验证                                                |\n| -R[分钟]                      | 设置等待时间                                               |\n\n","slug":"作业一","published":1,"date":"2020-11-01T00:47:05.568Z","updated":"2020-10-24T04:18:11.352Z","_id":"ckgye9w8a0003q0tz7gwg7pcq","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"作业1-学习-复习markdown语法\"><a href=\"#作业1-学习-复习markdown语法\" class=\"headerlink\" title=\"作业1: 学习/复习markdown语法\"></a>作业1: 学习/复习markdown语法</h2><p>已看。</p>\n<hr>\n<h2 id=\"作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\"><a href=\"#作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\" class=\"headerlink\" title=\"作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\"></a>作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh</h2><blockquote>\n<p>2-1、了解linux的基本命令</p>\n</blockquote>\n<ul>\n<li><p><strong>ls</strong></p>\n<ul>\n<li>ls：列出当前目录下的所有目录</li>\n<li>ls -F ：查看目录中的文件 </li>\n<li>ls -l ：显示文件和目录的详细资料 </li>\n<li>ls -a：显示隐藏文件 </li>\n<li>ls <em>[0-9]</em> ：显示包含数字的文件名和目录名 </li>\n</ul>\n</li>\n<li><p><strong>cd</strong></p>\n<ul>\n<li>cd ~ ： 子系统根目录</li>\n<li>cd ：进入个人的主目录</li>\n<li>cd ..  ：返回上级目录</li>\n<li>cd -  ：返回上次所在目录</li>\n<li>cd ../.. ：返回上两级目录</li>\n<li>cd /home ：进入‘/home’目录</li>\n</ul>\n</li>\n<li><p> <strong>tree</strong> ：显示文件和目录由根目录开始的树形结构</p>\n</li>\n<li><p><strong>mkdir</strong>：创建一个子目录</p>\n</li>\n<li><p><strong>rm</strong></p>\n<ul>\n<li>rm -f file1 删除一个叫做 ‘file1’ 的文件’ </li>\n<li>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ </li>\n<li>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 </li>\n<li>rm -rf dir1 dir2 同时删除两个目录及它们的内容</li>\n</ul>\n</li>\n<li><p><strong>l</strong>: 查看文件大小</p>\n</li>\n<li><p><strong>vi</strong>: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。</p>\n<p>​    使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：</p>\n<ol>\n<li><p>命令模式</p>\n<p>​    控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p>\n<ul>\n<li><p>①光标移动</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png\" alt=\"image-20201021100752987\"></p>\n</li>\n<li><p>②删除文本</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png\" alt=\"image-20201021100853637\"></p>\n</li>\n<li><p>③删除、复制、粘贴、查找、替换、撤销</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png\" alt=\"image-20201021101000073\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>插入模式</p>\n<p>​    只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png\" alt=\"image-20201021101108024\"></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>底行模式</p>\n<p>​    将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png\" alt=\"image-20201021101215216\"></p>\n<p>​    注意：在底行模式下的命令，需要按回车键才执行该命令。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>切换模式</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png\" alt=\"image-20201021101328117\"></p>\n<p>实现以上过程的命令：</p>\n<p>　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；</p>\n<p>　　过程②：按a、i、o或s键，实现命令模式——&gt;插入模式；</p>\n<p>　　过程③：按Esc键，实现插入模式——&gt;命令模式；</p>\n<p>　　过程④：输入：或 /，实现命令模式——&gt;底行模式；</p>\n<p>　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——&gt;命令模式；</p>\n<p>　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>curl</strong>：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>\n<p>语法：<code># curl [option] [url]</code></p>\n<ol>\n<li><p>保存访问的网页</p>\n<ul>\n<li>使用linux的重定向功能保存 <code> curl http://www.linux.com&gt;&gt;linux.html</code></li>\n<li>使用curl的内置option:-o(小写)保存网页 <code> curl -o linux.html http://www.linux.com</code></li>\n<li>使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）<code>curl -O http://www.linux.com/hello.sh</code></li>\n</ul>\n</li>\n<li><p>测试网页返回值 <code>curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com</code></p>\n<p><em>Ps:在脚本中，这是很常见的测试网站是否正常的用法</em></p>\n</li>\n<li><p>指定proxy服务器以及其端口</p>\n<p>很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理</p>\n<p><code>curl -x 192.168.100.100:1080 http://www.linux.com</code></p>\n</li>\n<li><p>cookie</p>\n<ul>\n<li><p>保存http的response里面的cookie信息。内置option:-c（小写）</p>\n<p><code>curl -c cookiec.txt  http://www.linux.com</code> 保存到cookiec.txt中</p>\n</li>\n<li><p>保存http的response里面的header信息。内置option: -D</p>\n<p><code>curl -D cookied.txt http://www.linux.com</code></p>\n</li>\n<li><p>使用cookie</p>\n<p>很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b</p>\n<p><code>curl -b cookiec.txt http://www.linux.com</code></p>\n</li>\n</ul>\n</li>\n<li><p>模仿浏览器</p>\n<p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站</p>\n<p><code>curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</code></p>\n<p>这样服务器端就会认为是使用IE8.0去访问的</p>\n</li>\n<li><p>伪造referer（盗链）</p>\n<p>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了<br>curl中内置option：-e可以让我们设定referer</p>\n<p><code>curl -e &quot;www.linux.com&quot; http://mail.linux.com</code></p>\n<p>这样就会让服务器其以为你是从<a href=\"http://www.linux.com点击某个链接过来的/\">www.linux.com点击某个链接过来的</a></p>\n</li>\n<li><p>下载文件</p>\n<ul>\n<li><p>利用curl下载文件 option：-o(小写大写)</p>\n</li>\n<li><p>循环下载</p>\n<p>有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O http:&#x2F;&#x2F;www.linux.com&#x2F;dodo[1-5].JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载重命名</p>\n<p><code>curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</code></p>\n<p>这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</p>\n</li>\n<li><p>分块下载</p>\n<p>有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># curl -r 0-100 -o dodo1_part1.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 100-200 -o dodo1_part2.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 200- -o dodo1_part3.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># cat dodo1_part* &gt; dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过ftp下载文件</p>\n<p>curl提供两种从ftp中下载的语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\">curl -O ftp:&#x2F;&#x2F;用户名:密码@www.linux.com&#x2F;dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示下载进度条 <code>curl -# -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>不会显示下载进度信息 <code>curl -s -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n</ul>\n</li>\n<li><p>断点续传</p>\n<p>在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果<br>如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传</p>\n<p><code>curl -C -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>上传文件</p>\n<p>curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -T dodo1.JPG -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;img&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>这样就向ftp服务器上传了文件dodo1.JPG</p>\n</li>\n<li><p>显示抓取错误 <code>curl -f http://www.linux.com/error</code></p>\n</li>\n</ol>\n</li>\n<li><p><strong>wget</strong>: wget命令用来从指定的URL下载文件。</p>\n<p> ​    wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>\n<p> 语法：<code>wget (选项) (url地址)</code></p>\n<p> 选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a&lt;日志文件&gt;</td>\n<td>在指定的日志文件中记录资料的执行过程；</td>\n</tr>\n<tr>\n<td>-A&lt;后缀名&gt;</td>\n<td>指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>进行后台的方式运行wget；</td>\n</tr>\n<tr>\n<td>-B&lt;连接地址&gt;</td>\n<td>设置参考的连接地址的基地地址；</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>继续执行上次终端的任务；</td>\n</tr>\n<tr>\n<td>-C&lt;标志&gt;</td>\n<td>设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>调试模式运行指令；</td>\n</tr>\n<tr>\n<td>-D&lt;域名列表&gt;</td>\n<td>设置顺着的域名列表，域名之间用“，”分隔；</td>\n</tr>\n<tr>\n<td>-e&lt;指令&gt;</td>\n<td>作为文件“.wgetrc”中的一部分执行指定的指令；</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>显示指令帮助信息；</td>\n</tr>\n<tr>\n<td>-i&lt;文件&gt;</td>\n<td>从指定文件获取要下载的URL地址；</td>\n</tr>\n<tr>\n<td>-l&lt;目录列表&gt;</td>\n<td>设置顺着的目录列表，多个目录用“，”分隔；</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>仅顺着关联的连接；</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归下载方式；</td>\n</tr>\n<tr>\n<td>-nc</td>\n<td>文件存在时，下载文件不覆盖原有文件；</td>\n</tr>\n<tr>\n<td>-nv</td>\n<td>下载时只显示更新和出错信息，不显示指令的详细执行过程；</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>不显示指令执行过程；</td>\n</tr>\n<tr>\n<td>-nh</td>\n<td>不查询主机名称；</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示详细执行过程；</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本信息；</td>\n</tr>\n<tr>\n<td>–passive-ftp</td>\n<td>使用被动模式PASV连接FTP服务器；</td>\n</tr>\n<tr>\n<td>–follow-ftp</td>\n<td>从HTML文件中下载FTP连接文件。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><code>wget http://test.com/testfile.zip </code>-&gt;下载指定文件到当前文件夹</p>\n</li>\n<li><p><code>wget -O wordpress.zip http://test.com/download </code>-&gt;指定保存名字</p>\n</li>\n<li><p><code>wget --limit-rate=300k http://www.linuxde.net/testfile.zip </code>-&gt;限制下载速度</p>\n</li>\n<li><p><code>wget -c http://www.linuxde.net/testfile.zip </code>-&gt;断点续传</p>\n</li>\n<li><p><code>wget -b http://www.linuxde.net/testfile.zip</code> -&gt;后台下载</p>\n<blockquote>\n<p><em>设置使用指定浏览器下载（伪装下载）</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.linuxde.net/testfile.zip</code></p>\n</li>\n<li><p><code>wget --spider url</code> -&gt;测试下载</p>\n</li>\n<li><p><code>wget --tries=40 URL</code> -&gt;设置重试次数为40</p>\n</li>\n<li><p><code>wget -i filelist.txt -&gt;从filelist.txt </code>  获取下载地址</p>\n<blockquote>\n<p><em>镜像网站</em></p>\n<p><em><code>--mirror</code>开户镜像下载。</em></p>\n<p><em><code>-p</code>下载所有为了<code>html</code>页面显示正常的文件。</em></p>\n<p><em><code>--convert-links</code>下载后，转换成本地的链接。</em></p>\n<p><em><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --mirror -p --convert-links -P ./LOCAL URL</code></p>\n</li>\n<li><p><code>wget --reject=gif url</code> -&gt;下载一个网站，但你不希望下载图片，可以使用这条命令</p>\n</li>\n<li><p><code>wget -o download.log URL </code>-&gt;把下载信息存入日志文件</p>\n</li>\n<li><p><code>wget -Q5m -i filelist.txt</code> -&gt;限制总下载文件大小</p>\n</li>\n<li><p><code>wget -r -A.pdf url </code>-&gt;下载指定格式文件</p>\n<blockquote>\n<p><em>FTP下载</em></p>\n</blockquote>\n</li>\n<li><p><code>wget ftp-url</code></p>\n</li>\n<li><p><code>wget --ftp-user=USERNAME --ftp-password=PASSWORD url</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>apt-get</strong>: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。</p>\n<p> apt-get命令一般需要root权限执行，所以一般跟着<code>sudo</code>命令。</p>\n<ul>\n<li><p><strong>更新、下载</strong></p>\n<blockquote>\n<p><strong>apt-get update</strong>  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。</p>\n<p><strong>sudo apt-get install packagename</strong>  :安装一个新软件包</p>\n<p><strong>upgrate</strong>：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。</p>\n</blockquote>\n</li>\n<li><p><strong>删除已安装的包</strong></p>\n<blockquote>\n<p><strong>apt-get remove packagename</strong>   :  卸载一个已安装的软件包（保留配置文档）</p>\n<p><strong>apt-get remove –purge packagename</strong>   :卸载一个已安装的软件包（删除配置文档）</p>\n<p><strong>apt-get autoremove packagename</strong>  :  删除包及其依赖的软件包</p>\n<p><strong>apt-get autoremove –purge packagname</strong>    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点</p>\n</blockquote>\n</li>\n<li><p><strong>清理系统</strong></p>\n<blockquote>\n<p><strong>apt-get autoclean</strong>   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。</p>\n<p><strong>apt-get clean</strong>  :  清除检索到的包文件的本地存储库.</p>\n</blockquote>\n</li>\n<li><p><strong>apt-cache</strong></p>\n<blockquote>\n<p>search：搜索包</p>\n<p>pkgnames：搜索具有特定名称的包</p>\n<p>showpkg：查看包的详细信息</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2、了解学习oh-my-zsh</p>\n</blockquote>\n<p>​    Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p>\n<hr>\n<h2 id=\"作业三：yum是什么\"><a href=\"#作业三：yum是什么\" class=\"headerlink\" title=\"作业三：yum是什么\"></a>作业三：yum是什么</h2><p>​        Yum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的<strong>Shell前端软件包管理器</strong>。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>\n<p>​        yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。</p>\n<p>​        yum的常用命令：</p>\n<table>\n<thead>\n<tr>\n<th>yum check-update</th>\n<th>列出所有可更新的软件清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>yum update</td>\n<td>安装所有更新软件</td>\n</tr>\n<tr>\n<td>yum -y install <package_name></td>\n<td>安装指定的软件</td>\n</tr>\n<tr>\n<td>yum update <package_name></td>\n<td>更新指定的软件</td>\n</tr>\n<tr>\n<td>yum list  <package_name></td>\n<td>不加<package_name>列出所有可安裝的软件清单，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum -y remove <package_name></td>\n<td>删除软件</td>\n</tr>\n<tr>\n<td>yum search <package_name></td>\n<td>查找软件</td>\n</tr>\n<tr>\n<td>yum list installed</td>\n<td>列出所有已安装的软件包</td>\n</tr>\n<tr>\n<td>yum list extras</td>\n<td>列出所有已安装但不在Yum Repository 內的软件包</td>\n</tr>\n<tr>\n<td>yum clean all</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包及旧的headers</td>\n</tr>\n<tr>\n<td>yum info <package_name></td>\n<td>不加<package_name>列出所有软件包的信息，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum provides <package_name></td>\n<td>列出软件包提供哪些文件</td>\n</tr>\n<tr>\n<td>yum clean packages</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包</td>\n</tr>\n<tr>\n<td>yum deplist <package_name></td>\n<td>显示软件包依赖关系</td>\n</tr>\n<tr>\n<td>-y</td>\n<td>自动应答yes</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>忽略错误</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>静默执行</td>\n</tr>\n<tr>\n<td>–skip-broken</td>\n<td>忽略依赖问题</td>\n</tr>\n<tr>\n<td>–nogpgcheck</td>\n<td>忽略GPG验证</td>\n</tr>\n<tr>\n<td>-R[分钟]</td>\n<td>设置等待时间</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"作业1-学习-复习markdown语法\"><a href=\"#作业1-学习-复习markdown语法\" class=\"headerlink\" title=\"作业1: 学习/复习markdown语法\"></a>作业1: 学习/复习markdown语法</h2><p>已看。</p>\n<hr>\n<h2 id=\"作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\"><a href=\"#作业2-了解linux的基本命令-ls-l-vi-vim-curl-wget-apt-get-了解学习oh-my-zsh\" class=\"headerlink\" title=\"作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh\"></a>作业2: 了解linux的基本命令: ls, l, vi, vim, curl, wget, apt-get,了解学习oh-my-zsh</h2><blockquote>\n<p>2-1、了解linux的基本命令</p>\n</blockquote>\n<ul>\n<li><p><strong>ls</strong></p>\n<ul>\n<li>ls：列出当前目录下的所有目录</li>\n<li>ls -F ：查看目录中的文件 </li>\n<li>ls -l ：显示文件和目录的详细资料 </li>\n<li>ls -a：显示隐藏文件 </li>\n<li>ls <em>[0-9]</em> ：显示包含数字的文件名和目录名 </li>\n</ul>\n</li>\n<li><p><strong>cd</strong></p>\n<ul>\n<li>cd ~ ： 子系统根目录</li>\n<li>cd ：进入个人的主目录</li>\n<li>cd ..  ：返回上级目录</li>\n<li>cd -  ：返回上次所在目录</li>\n<li>cd ../.. ：返回上两级目录</li>\n<li>cd /home ：进入‘/home’目录</li>\n</ul>\n</li>\n<li><p> <strong>tree</strong> ：显示文件和目录由根目录开始的树形结构</p>\n</li>\n<li><p><strong>mkdir</strong>：创建一个子目录</p>\n</li>\n<li><p><strong>rm</strong></p>\n<ul>\n<li>rm -f file1 删除一个叫做 ‘file1’ 的文件’ </li>\n<li>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ </li>\n<li>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 </li>\n<li>rm -rf dir1 dir2 同时删除两个目录及它们的内容</li>\n</ul>\n</li>\n<li><p><strong>l</strong>: 查看文件大小</p>\n</li>\n<li><p><strong>vi</strong>: VI是Linux系统的一个文本编辑器，该编辑器可以通过使用VI命令来操作，从而完成对文本的编辑。</p>\n<p>​    使用VI命令编辑文本时，有三种编辑模式——命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）。各模式的功能区分如下：</p>\n<ol>\n<li><p>命令模式</p>\n<p>​    控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p>\n<ul>\n<li><p>①光标移动</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100752987.png\" alt=\"image-20201021100752987\"></p>\n</li>\n<li><p>②删除文本</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021100853637.png\" alt=\"image-20201021100853637\"></p>\n</li>\n<li><p>③删除、复制、粘贴、查找、替换、撤销</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101000073.png\" alt=\"image-20201021101000073\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>插入模式</p>\n<p>​    只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。插入模式可以移动和定位光标（小范围定位）、自由输入文本、替换文本等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101108024.png\" alt=\"image-20201021101108024\"></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>底行模式</p>\n<p>​    将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101215216.png\" alt=\"image-20201021101215216\"></p>\n<p>​    注意：在底行模式下的命令，需要按回车键才执行该命令。</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>切换模式</p>\n<p><img src=\"C:\\Users\\陈莉媛\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201021101328117.png\" alt=\"image-20201021101328117\"></p>\n<p>实现以上过程的命令：</p>\n<p>　　过程①：输入vi [文件名]，按回车键执行该命令，进入命令模式；</p>\n<p>　　过程②：按a、i、o或s键，实现命令模式——&gt;插入模式；</p>\n<p>　　过程③：按Esc键，实现插入模式——&gt;命令模式；</p>\n<p>　　过程④：输入：或 /，实现命令模式——&gt;底行模式；</p>\n<p>　　过程⑤：按Esc键、连按Esc键2次或删除全部底行内容，实现底行模式 ——&gt;命令模式；</p>\n<p>　　过程⑥：输入:q、:q!或:wq，按回车键执行该命令，从命令模式退出。</p>\n</li>\n</ol>\n<ul>\n<li><p><strong>curl</strong>：是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>\n<p>语法：<code># curl [option] [url]</code></p>\n<ol>\n<li><p>保存访问的网页</p>\n<ul>\n<li>使用linux的重定向功能保存 <code> curl http://www.linux.com&gt;&gt;linux.html</code></li>\n<li>使用curl的内置option:-o(小写)保存网页 <code> curl -o linux.html http://www.linux.com</code></li>\n<li>使用curl的内置option:-O(大写)保存网页中的文件(后面的url要具体到某个文件）<code>curl -O http://www.linux.com/hello.sh</code></li>\n</ul>\n</li>\n<li><p>测试网页返回值 <code>curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com</code></p>\n<p><em>Ps:在脚本中，这是很常见的测试网站是否正常的用法</em></p>\n</li>\n<li><p>指定proxy服务器以及其端口</p>\n<p>很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理</p>\n<p><code>curl -x 192.168.100.100:1080 http://www.linux.com</code></p>\n</li>\n<li><p>cookie</p>\n<ul>\n<li><p>保存http的response里面的cookie信息。内置option:-c（小写）</p>\n<p><code>curl -c cookiec.txt  http://www.linux.com</code> 保存到cookiec.txt中</p>\n</li>\n<li><p>保存http的response里面的header信息。内置option: -D</p>\n<p><code>curl -D cookied.txt http://www.linux.com</code></p>\n</li>\n<li><p>使用cookie</p>\n<p>很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b</p>\n<p><code>curl -b cookiec.txt http://www.linux.com</code></p>\n</li>\n</ul>\n</li>\n<li><p>模仿浏览器</p>\n<p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站</p>\n<p><code>curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</code></p>\n<p>这样服务器端就会认为是使用IE8.0去访问的</p>\n</li>\n<li><p>伪造referer（盗链）</p>\n<p>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了<br>curl中内置option：-e可以让我们设定referer</p>\n<p><code>curl -e &quot;www.linux.com&quot; http://mail.linux.com</code></p>\n<p>这样就会让服务器其以为你是从<a href=\"http://www.linux.com点击某个链接过来的/\">www.linux.com点击某个链接过来的</a></p>\n</li>\n<li><p>下载文件</p>\n<ul>\n<li><p>利用curl下载文件 option：-o(小写大写)</p>\n</li>\n<li><p>循环下载</p>\n<p>有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。下载dodo1-5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O http:&#x2F;&#x2F;www.linux.com&#x2F;dodo[1-5].JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载重命名</p>\n<p><code>curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</code></p>\n<p>这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</p>\n</li>\n<li><p>分块下载</p>\n<p>有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># curl -r 0-100 -o dodo1_part1.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 100-200 -o dodo1_part2.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># curl -r 200- -o dodo1_part3.JPG http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\"># cat dodo1_part* &gt; dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过ftp下载文件</p>\n<p>curl提供两种从ftp中下载的语法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG</span><br><span class=\"line\">curl -O ftp:&#x2F;&#x2F;用户名:密码@www.linux.com&#x2F;dodo1.JPG</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示下载进度条 <code>curl -# -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>不会显示下载进度信息 <code>curl -s -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n</ul>\n</li>\n<li><p>断点续传</p>\n<p>在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果<br>如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传</p>\n<p><code>curl -C -O http://www.linux.com/dodo1.JPG</code></p>\n</li>\n<li><p>上传文件</p>\n<p>curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -T dodo1.JPG -u 用户名:密码 ftp:&#x2F;&#x2F;www.linux.com&#x2F;img&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>这样就向ftp服务器上传了文件dodo1.JPG</p>\n</li>\n<li><p>显示抓取错误 <code>curl -f http://www.linux.com/error</code></p>\n</li>\n</ol>\n</li>\n<li><p><strong>wget</strong>: wget命令用来从指定的URL下载文件。</p>\n<p> ​    wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>\n<p> 语法：<code>wget (选项) (url地址)</code></p>\n<p> 选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-a&lt;日志文件&gt;</td>\n<td>在指定的日志文件中记录资料的执行过程；</td>\n</tr>\n<tr>\n<td>-A&lt;后缀名&gt;</td>\n<td>指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</td>\n</tr>\n<tr>\n<td>-b</td>\n<td>进行后台的方式运行wget；</td>\n</tr>\n<tr>\n<td>-B&lt;连接地址&gt;</td>\n<td>设置参考的连接地址的基地地址；</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>继续执行上次终端的任务；</td>\n</tr>\n<tr>\n<td>-C&lt;标志&gt;</td>\n<td>设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>调试模式运行指令；</td>\n</tr>\n<tr>\n<td>-D&lt;域名列表&gt;</td>\n<td>设置顺着的域名列表，域名之间用“，”分隔；</td>\n</tr>\n<tr>\n<td>-e&lt;指令&gt;</td>\n<td>作为文件“.wgetrc”中的一部分执行指定的指令；</td>\n</tr>\n<tr>\n<td>-h</td>\n<td>显示指令帮助信息；</td>\n</tr>\n<tr>\n<td>-i&lt;文件&gt;</td>\n<td>从指定文件获取要下载的URL地址；</td>\n</tr>\n<tr>\n<td>-l&lt;目录列表&gt;</td>\n<td>设置顺着的目录列表，多个目录用“，”分隔；</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>仅顺着关联的连接；</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>递归下载方式；</td>\n</tr>\n<tr>\n<td>-nc</td>\n<td>文件存在时，下载文件不覆盖原有文件；</td>\n</tr>\n<tr>\n<td>-nv</td>\n<td>下载时只显示更新和出错信息，不显示指令的详细执行过程；</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>不显示指令执行过程；</td>\n</tr>\n<tr>\n<td>-nh</td>\n<td>不查询主机名称；</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示详细执行过程；</td>\n</tr>\n<tr>\n<td>-V</td>\n<td>显示版本信息；</td>\n</tr>\n<tr>\n<td>–passive-ftp</td>\n<td>使用被动模式PASV连接FTP服务器；</td>\n</tr>\n<tr>\n<td>–follow-ftp</td>\n<td>从HTML文件中下载FTP连接文件。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><code>wget http://test.com/testfile.zip </code>-&gt;下载指定文件到当前文件夹</p>\n</li>\n<li><p><code>wget -O wordpress.zip http://test.com/download </code>-&gt;指定保存名字</p>\n</li>\n<li><p><code>wget --limit-rate=300k http://www.linuxde.net/testfile.zip </code>-&gt;限制下载速度</p>\n</li>\n<li><p><code>wget -c http://www.linuxde.net/testfile.zip </code>-&gt;断点续传</p>\n</li>\n<li><p><code>wget -b http://www.linuxde.net/testfile.zip</code> -&gt;后台下载</p>\n<blockquote>\n<p><em>设置使用指定浏览器下载（伪装下载）</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.linuxde.net/testfile.zip</code></p>\n</li>\n<li><p><code>wget --spider url</code> -&gt;测试下载</p>\n</li>\n<li><p><code>wget --tries=40 URL</code> -&gt;设置重试次数为40</p>\n</li>\n<li><p><code>wget -i filelist.txt -&gt;从filelist.txt </code>  获取下载地址</p>\n<blockquote>\n<p><em>镜像网站</em></p>\n<p><em><code>--mirror</code>开户镜像下载。</em></p>\n<p><em><code>-p</code>下载所有为了<code>html</code>页面显示正常的文件。</em></p>\n<p><em><code>--convert-links</code>下载后，转换成本地的链接。</em></p>\n<p><em><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录</em></p>\n</blockquote>\n</li>\n<li><p><code>wget --mirror -p --convert-links -P ./LOCAL URL</code></p>\n</li>\n<li><p><code>wget --reject=gif url</code> -&gt;下载一个网站，但你不希望下载图片，可以使用这条命令</p>\n</li>\n<li><p><code>wget -o download.log URL </code>-&gt;把下载信息存入日志文件</p>\n</li>\n<li><p><code>wget -Q5m -i filelist.txt</code> -&gt;限制总下载文件大小</p>\n</li>\n<li><p><code>wget -r -A.pdf url </code>-&gt;下载指定格式文件</p>\n<blockquote>\n<p><em>FTP下载</em></p>\n</blockquote>\n</li>\n<li><p><code>wget ftp-url</code></p>\n</li>\n<li><p><code>wget --ftp-user=USERNAME --ftp-password=PASSWORD url</code></p>\n</li>\n</ul>\n</li>\n<li><p><strong>apt-get</strong>: 适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。</p>\n<p> apt-get命令一般需要root权限执行，所以一般跟着<code>sudo</code>命令。</p>\n<ul>\n<li><p><strong>更新、下载</strong></p>\n<blockquote>\n<p><strong>apt-get update</strong>  :  在修改/etc/apt/sources.list或/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。</p>\n<p><strong>sudo apt-get install packagename</strong>  :安装一个新软件包</p>\n<p><strong>upgrate</strong>：升级（dist-upgrade，将系统升级到新版本， 不建议使用）。在运行apt-get upgrade命令时加上-u选项很有用（即：apt-get -u upgrade)。这个选项让APT显示完整的可更新软件包列表。</p>\n</blockquote>\n</li>\n<li><p><strong>删除已安装的包</strong></p>\n<blockquote>\n<p><strong>apt-get remove packagename</strong>   :  卸载一个已安装的软件包（保留配置文档）</p>\n<p><strong>apt-get remove –purge packagename</strong>   :卸载一个已安装的软件包（删除配置文档）</p>\n<p><strong>apt-get autoremove packagename</strong>  :  删除包及其依赖的软件包</p>\n<p><strong>apt-get autoremove –purge packagname</strong>    删除包及其依赖的软件包+配置文件，比上面的要删除的彻底一点</p>\n</blockquote>\n</li>\n<li><p><strong>清理系统</strong></p>\n<blockquote>\n<p><strong>apt-get autoclean</strong>   :  删除现在有更新版本的检索包文件，它们将不再使用。apt会把已装或已卸的软件都备份在硬盘上，所以假如需要空间的话，能够让这个命令来删除您已卸载掉的软件的备份。</p>\n<p><strong>apt-get clean</strong>  :  清除检索到的包文件的本地存储库.</p>\n</blockquote>\n</li>\n<li><p><strong>apt-cache</strong></p>\n<blockquote>\n<p>search：搜索包</p>\n<p>pkgnames：搜索具有特定名称的包</p>\n<p>showpkg：查看包的详细信息</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>2-2、了解学习oh-my-zsh</p>\n</blockquote>\n<p>​    Oh My Zsh是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。</p>\n<hr>\n<h2 id=\"作业三：yum是什么\"><a href=\"#作业三：yum是什么\" class=\"headerlink\" title=\"作业三：yum是什么\"></a>作业三：yum是什么</h2><p>​        Yum（全称为 Yellow dog Updater,  Modified）是一个在Fedora和RedHat以及CentOS中的<strong>Shell前端软件包管理器</strong>。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>\n<p>​        yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header，  header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些  header并加以分析，才能自动化地完成余下的任务。它能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。自己本身也可以做yum服务器，本身可以根据光盘镜像做yum服务器。</p>\n<p>​        yum的常用命令：</p>\n<table>\n<thead>\n<tr>\n<th>yum check-update</th>\n<th>列出所有可更新的软件清单</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>yum update</td>\n<td>安装所有更新软件</td>\n</tr>\n<tr>\n<td>yum -y install <package_name></td>\n<td>安装指定的软件</td>\n</tr>\n<tr>\n<td>yum update <package_name></td>\n<td>更新指定的软件</td>\n</tr>\n<tr>\n<td>yum list  <package_name></td>\n<td>不加<package_name>列出所有可安裝的软件清单，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum -y remove <package_name></td>\n<td>删除软件</td>\n</tr>\n<tr>\n<td>yum search <package_name></td>\n<td>查找软件</td>\n</tr>\n<tr>\n<td>yum list installed</td>\n<td>列出所有已安装的软件包</td>\n</tr>\n<tr>\n<td>yum list extras</td>\n<td>列出所有已安装但不在Yum Repository 內的软件包</td>\n</tr>\n<tr>\n<td>yum clean all</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包及旧的headers</td>\n</tr>\n<tr>\n<td>yum info <package_name></td>\n<td>不加<package_name>列出所有软件包的信息，加了列出指定的</td>\n</tr>\n<tr>\n<td>yum provides <package_name></td>\n<td>列出软件包提供哪些文件</td>\n</tr>\n<tr>\n<td>yum clean packages</td>\n<td>清除缓存目录(/var/cache/yum)下的软件包</td>\n</tr>\n<tr>\n<td>yum deplist <package_name></td>\n<td>显示软件包依赖关系</td>\n</tr>\n<tr>\n<td>-y</td>\n<td>自动应答yes</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>忽略错误</td>\n</tr>\n<tr>\n<td>-q</td>\n<td>静默执行</td>\n</tr>\n<tr>\n<td>–skip-broken</td>\n<td>忽略依赖问题</td>\n</tr>\n<tr>\n<td>–nogpgcheck</td>\n<td>忽略GPG验证</td>\n</tr>\n<tr>\n<td>-R[分钟]</td>\n<td>设置等待时间</td>\n</tr>\n</tbody></table>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}